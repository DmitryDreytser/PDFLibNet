; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\projects\PDFLibNet\libAFPDFLib\PDFPageInterop.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat


PUBLIC	??0?$DynArray@VpdfPageSelection@@@@QAE@XZ	; DynArray<pdfPageSelection>::DynArray<pdfPageSelection>
PUBLIC	??_GTextPage@@QAEPAXI@Z				; TextPage::`scalar deleting destructor'
PUBLIC	??0CRect@@QAE@HHHH@Z				; CRect::CRect
PUBLIC	??0pdfPageSelection@@QAE@PA_WNHHHH@Z		; pdfPageSelection::pdfPageSelection
PUBLIC	?Add@?$DynArray@VpdfPageSelection@@@@QAEXABVpdfPageSelection@@@Z ; DynArray<pdfPageSelection>::Add
PUBLIC	?Clear@?$DynArray@VpdfPageSelection@@@@QAEXXZ	; DynArray<pdfPageSelection>::Clear
PUBLIC	?getChar@GString@@QAEDH@Z			; GString::getChar
PUBLIC	??_GGString@@QAEPAXI@Z				; GString::`scalar deleting destructor'
PUBLIC	?getCropWidth@Page@@QAENXZ			; Page::getCropWidth
PUBLIC	?getPageCropWidth@PDFDoc@@QAENH@Z		; PDFDoc::getPageCropWidth
PUBLIC	?getRotate@PageAttrs@@QAEHXZ			; PageAttrs::getRotate
PUBLIC	?getRotate@Page@@QAEHXZ				; Page::getRotate
PUBLIC	?getPageRotate@PDFDoc@@QAEHH@Z			; PDFDoc::getPageRotate
PUBLIC	?getCropBox@PageAttrs@@QAEPAVPDFRectangle@@XZ	; PageAttrs::getCropBox
PUBLIC	?getCropHeight@Page@@QAENXZ			; Page::getCropHeight
PUBLIC	?getPageCropHeight@PDFDoc@@QAENH@Z		; PDFDoc::getPageCropHeight
PUBLIC	??A?$DynArray@VpdfPageSelection@@@@QAEAAVpdfPageSelection@@I@Z ; DynArray<pdfPageSelection>::operator[]
PUBLIC	?GetSize@?$DynArray@VpdfPageSelection@@@@QAEIXZ	; DynArray<pdfPageSelection>::GetSize
PUBLIC	?GetCount@?$DynArray@VpdfPageSelection@@@@QAEIXZ ; DynArray<pdfPageSelection>::GetCount
PUBLIC	?dyn_array_step@?$DynArray@UImageInfo@@@@0HB	; DynArray<ImageInfo>::dyn_array_step
PUBLIC	?dyn_array_mult@?$DynArray@UImageInfo@@@@0HB	; DynArray<ImageInfo>::dyn_array_mult
PUBLIC	?dyn_array_step@?$DynArray@VpdfPageSelection@@@@0HB ; DynArray<pdfPageSelection>::dyn_array_step
PUBLIC	?dyn_array_mult@?$DynArray@VpdfPageSelection@@@@0HB ; DynArray<pdfPageSelection>::dyn_array_mult
PUBLIC	??_C@_05EGJIMALK@UTF?98?$AA@			; `string'
PUBLIC	??_C@_06MNKGPLIC@letter?$AA@			; `string'
PUBLIC	??_C@_03MCAEDFBD@A?$CFd?$AA@			; `string'
PUBLIC	??_C@_07CIFAGBMG@unknown?$AA@			; `string'
PUBLIC	??_R0?AW4exception@?$DynArray@VpdfPageSelection@@@@@8 ; enum DynArray<pdfPageSelection>::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AW4exception@?$DynArray@VpdfPageSelection@@@@@84
PUBLIC	__CTA1?AW4exception@?$DynArray@VpdfPageSelection@@@@
PUBLIC	__TI1?AW4exception@?$DynArray@VpdfPageSelection@@@@
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	__imp__MultiByteToWideChar@24:PROC
EXTRN	__imp__realloc:PROC
EXTRN	__imp__Sleep@4:PROC
EXTRN	__imp__sprintf:PROC
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	__imp__CreatePen@12:PROC
EXTRN	__imp__GetStockObject@4:PROC
EXTRN	__imp__Rectangle@20:PROC
EXTRN	__imp__SelectObject@8:PROC
EXTRN	__imp__InvertRect@8:PROC
_EmptyChar DW	01H DUP (?)
;	COMDAT __TI1?AW4exception@?$DynArray@VpdfPageSelection@@@@
xdata$x	SEGMENT
__TI1?AW4exception@?$DynArray@VpdfPageSelection@@@@ DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__CTA1?AW4exception@?$DynArray@VpdfPageSelection@@@@
xdata$x	ENDS
;	COMDAT __CTA1?AW4exception@?$DynArray@VpdfPageSelection@@@@
xdata$x	SEGMENT
__CTA1?AW4exception@?$DynArray@VpdfPageSelection@@@@ DD 01H
	DD	FLAT:__CT??_R0?AW4exception@?$DynArray@VpdfPageSelection@@@@@84
xdata$x	ENDS
;	COMDAT __CT??_R0?AW4exception@?$DynArray@VpdfPageSelection@@@@@84
xdata$x	SEGMENT
__CT??_R0?AW4exception@?$DynArray@VpdfPageSelection@@@@@84 DD 01H
	DD	FLAT:??_R0?AW4exception@?$DynArray@VpdfPageSelection@@@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT ??_R0?AW4exception@?$DynArray@VpdfPageSelection@@@@@8
_DATA	SEGMENT
??_R0?AW4exception@?$DynArray@VpdfPageSelection@@@@@8 DD FLAT:??_7type_info@@6B@ ; enum DynArray<pdfPageSelection>::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AW4exception@?$DynArray@VpdfPageSelection@@@@', 00H
_DATA	ENDS
;	COMDAT ??_C@_07CIFAGBMG@unknown?$AA@
CONST	SEGMENT
??_C@_07CIFAGBMG@unknown?$AA@ DB 'unknown', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03MCAEDFBD@A?$CFd?$AA@
CONST	SEGMENT
??_C@_03MCAEDFBD@A?$CFd?$AA@ DB 'A%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06MNKGPLIC@letter?$AA@
CONST	SEGMENT
??_C@_06MNKGPLIC@letter?$AA@ DB 'letter', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05EGJIMALK@UTF?98?$AA@
CONST	SEGMENT
??_C@_05EGJIMALK@UTF?98?$AA@ DB 'UTF-8', 00H		; `string'
CONST	ENDS
;	COMDAT ?dyn_array_mult@?$DynArray@VpdfPageSelection@@@@0HB
CONST	SEGMENT
?dyn_array_mult@?$DynArray@VpdfPageSelection@@@@0HB DD 02H ; DynArray<pdfPageSelection>::dyn_array_mult
CONST	ENDS
;	COMDAT ?dyn_array_step@?$DynArray@VpdfPageSelection@@@@0HB
CONST	SEGMENT
?dyn_array_step@?$DynArray@VpdfPageSelection@@@@0HB DD 080H ; DynArray<pdfPageSelection>::dyn_array_step
CONST	ENDS
;	COMDAT ?dyn_array_mult@?$DynArray@UImageInfo@@@@0HB
CONST	SEGMENT
?dyn_array_mult@?$DynArray@UImageInfo@@@@0HB DD 02H	; DynArray<ImageInfo>::dyn_array_mult
CONST	ENDS
;	COMDAT ?dyn_array_step@?$DynArray@UImageInfo@@@@0HB
CONST	SEGMENT
?dyn_array_step@?$DynArray@UImageInfo@@@@0HB DD 080H	; DynArray<ImageInfo>::dyn_array_step
	ORG $+14260
__bad_alloc_Message DD FLAT:??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
; Function compile flags: /Ogtpy
; File c:\projects\pdflibnet\libafpdflib\dynarray.h
;	COMDAT ?Clear@?$DynArray@VpdfPageSelection@@@@QAEXXZ
_TEXT	SEGMENT
?Clear@?$DynArray@VpdfPageSelection@@@@QAEXXZ PROC	; DynArray<pdfPageSelection>::Clear, COMDAT
; _this$ = esi

; 150  :     size = 0; 
; 151  : 	array = (T *)realloc(array, sizeof(T)*dyn_array_step); 

	mov	eax, DWORD PTR [esi]
	push	5120					; 00001400H
	push	eax
	mov	DWORD PTR [esi+4], 0
	call	DWORD PTR __imp__realloc
	add	esp, 8
	mov	DWORD PTR [esi], eax

; 152  : 				  // set initial memory size again 
; 153  : 	realsize = dyn_array_step;

	mov	DWORD PTR [esi+8], 128			; 00000080H

; 154  : }

	ret	0
?Clear@?$DynArray@VpdfPageSelection@@@@QAEXXZ ENDP	; DynArray<pdfPageSelection>::Clear
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetSize@?$DynArray@VpdfPageSelection@@@@QAEIXZ
_TEXT	SEGMENT
?GetSize@?$DynArray@VpdfPageSelection@@@@QAEIXZ PROC	; DynArray<pdfPageSelection>::GetSize, COMDAT
; _this$ = eax

; 102  :     return size; // simply return size

	mov	eax, DWORD PTR [eax+4]

; 103  : }

	ret	0
?GetSize@?$DynArray@VpdfPageSelection@@@@QAEIXZ ENDP	; DynArray<pdfPageSelection>::GetSize
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Add@?$DynArray@VpdfPageSelection@@@@QAEXABVpdfPageSelection@@@Z
_TEXT	SEGMENT
$T161060 = 8						; size = 4
_item$ = 8						; size = 4
?Add@?$DynArray@VpdfPageSelection@@@@QAEXABVpdfPageSelection@@@Z PROC ; DynArray<pdfPageSelection>::Add, COMDAT
; _this$ = eax

; 170  : {

	push	esi
	mov	esi, eax

; 171  :     size++;

	inc	DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+4]

; 172  :  
; 173  :     if (size > realsize)

	mov	eax, DWORD PTR [esi+8]
	cmp	ecx, eax
	jbe	SHORT $LN1@Add@4

; 174  :     {
; 175  : 		realsize *= dyn_array_mult;
; 176  :  
; 177  : 		array = (T *)realloc(array, sizeof(T)*realsize);

	mov	ecx, DWORD PTR [esi]
	add	eax, eax
	mov	DWORD PTR [esi+8], eax
	lea	eax, DWORD PTR [eax+eax*4]
	add	eax, eax
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	call	DWORD PTR __imp__realloc
	add	esp, 8
	mov	DWORD PTR [esi], eax

; 178  :  
; 179  : 		if (array == NULL)

	test	eax, eax
	jne	SHORT $LN1@Add@4

; 180  : 			throw MEMFAIL;

	push	OFFSET __TI1?AW4exception@?$DynArray@VpdfPageSelection@@@@
	lea	edx, DWORD PTR $T161060[esp+4]
	push	edx
	mov	DWORD PTR $T161060[esp+8], eax
	call	__CxxThrowException@8
$LN6@Add@4:
$LN1@Add@4:

; 181  :     }
; 182  :  
; 183  : 	array[size-1] = item;

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	mov	esi, DWORD PTR _item$[esp]
	push	edi
	lea	eax, DWORD PTR [eax+eax*4]
	lea	edi, DWORD PTR [ecx+eax*8-40]
	mov	ecx, 10					; 0000000aH
	rep movsd
	pop	edi
	pop	esi

; 184  : }

	ret	4
$LN5@Add@4:
?Add@?$DynArray@VpdfPageSelection@@@@QAEXABVpdfPageSelection@@@Z ENDP ; DynArray<pdfPageSelection>::Add
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??A?$DynArray@VpdfPageSelection@@@@QAEAAVpdfPageSelection@@I@Z
_TEXT	SEGMENT
??A?$DynArray@VpdfPageSelection@@@@QAEAAVpdfPageSelection@@I@Z PROC ; DynArray<pdfPageSelection>::operator[], COMDAT
; _this$ = ecx
; _index$ = eax

; 165  :     return array[index]; // return array element 

	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+eax*4]
	lea	eax, DWORD PTR [edx+eax*8]

; 166  : }

	ret	0
??A?$DynArray@VpdfPageSelection@@@@QAEAAVpdfPageSelection@@I@Z ENDP ; DynArray<pdfPageSelection>::operator[]
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$DynArray@VpdfPageSelection@@@@QAE@XZ
_TEXT	SEGMENT
$T161069 = -4						; size = 4
??0?$DynArray@VpdfPageSelection@@@@QAE@XZ PROC		; DynArray<pdfPageSelection>::DynArray<pdfPageSelection>, COMDAT
; _this$ = esi

; 47   : {

	push	ecx

; 48   :     realsize = dyn_array_step; // First, allocate step 
; 49   : 							   // for dyn_array_step items
; 50   :     size = 0;
; 51   :     array = (T *)malloc(realsize*sizeof(T));

	push	5120					; 00001400H
	mov	DWORD PTR [esi+8], 128			; 00000080H
	mov	DWORD PTR [esi+4], 0
	call	DWORD PTR __imp__malloc
	add	esp, 4
	mov	DWORD PTR [esi], eax

; 52   :  
; 53   :     if (array == NULL)

	test	eax, eax
	jne	SHORT $LN1@DynArray@7

; 54   : 		throw MEMFAIL;

	mov	DWORD PTR $T161069[esp+4], eax
	push	OFFSET __TI1?AW4exception@?$DynArray@VpdfPageSelection@@@@
	lea	eax, DWORD PTR $T161069[esp+8]
	push	eax
	call	__CxxThrowException@8
$LN5@DynArray@7:
$LN1@DynArray@7:

; 55   : }

	mov	eax, esi
	pop	ecx
	ret	0
$LN4@DynArray@7:
??0?$DynArray@VpdfPageSelection@@@@QAE@XZ ENDP		; DynArray<pdfPageSelection>::DynArray<pdfPageSelection>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetCount@?$DynArray@VpdfPageSelection@@@@QAEIXZ
_TEXT	SEGMENT
?GetCount@?$DynArray@VpdfPageSelection@@@@QAEIXZ PROC	; DynArray<pdfPageSelection>::GetCount, COMDAT
; _this$ = eax

; 17   : 		return this->GetSize();

	mov	eax, DWORD PTR [eax+4]

; 18   : 	}

	ret	0
?GetCount@?$DynArray@VpdfPageSelection@@@@QAEIXZ ENDP	; DynArray<pdfPageSelection>::GetCount
_TEXT	ENDS
PUBLIC	?RenderSelection@PDFPageInterop@@QAEXNJKKH@Z	; PDFPageInterop::RenderSelection
; Function compile flags: /Ogtpy
; File c:\projects\pdflibnet\libafpdflib\pdfpageinterop.cpp
;	COMDAT ?RenderSelection@PDFPageInterop@@QAEXNJKKH@Z
_TEXT	SEGMENT
tv308 = -36						; size = 4
_old_pen$ = -32						; size = 4
_old_brush$ = -28					; size = 4
_nsel$85593 = -24					; size = 24
_dpi$ = 8						; size = 8
?RenderSelection@PDFPageInterop@@QAEXNJKKH@Z PROC	; PDFPageInterop::RenderSelection, COMDAT
; _this$ = eax
; _hdc$ = edi
; _linecolor$ = ecx

; 420  : {

	sub	esp, 36					; 00000024H
	push	ebx

; 421  : 	HDC dc =(HDC)hdc;
; 422  : 	DynArray<pdfPageSelection> *arr= (DynArray<pdfPageSelection> *)this->_selectionArray;

	mov	ebx, DWORD PTR [eax+12]
	push	ebp
	push	esi

; 423  : 	HGDIOBJ draw_pen, old_pen;
; 424  : 	HGDIOBJ old_brush;
; 425  : 
; 426  : 	draw_pen = CreatePen(PS_SOLID, 0,(COLORREF)linecolor);

	push	ecx
	xor	ebp, ebp
	push	ebp
	push	ebp
	call	DWORD PTR __imp__CreatePen@12

; 427  : 	old_pen = SelectObject(dc,draw_pen);

	mov	esi, DWORD PTR __imp__SelectObject@8
	push	eax
	push	edi
	call	esi

; 428  : 	//old_brush = SelectStockObject(dc,NULL_BRUSH);
; 429  : 	old_brush = SelectObject(dc,GetStockObject(NULL_BRUSH));

	push	5
	mov	DWORD PTR _old_pen$[esp+52], eax
	call	DWORD PTR __imp__GetStockObject@4
	push	eax
	push	edi
	call	esi
	mov	DWORD PTR _old_brush$[esp+48], eax

; 430  : 
; 431  : 	for(int i=0;i<arr->GetCount();i++){

	cmp	DWORD PTR [ebx+4], ebp
	jbe	$LN1@RenderSele

; 421  : 	HDC dc =(HDC)hdc;
; 422  : 	DynArray<pdfPageSelection> *arr= (DynArray<pdfPageSelection> *)this->_selectionArray;

	mov	DWORD PTR tv308[esp+48], ebp
	npad	1
$LL16@RenderSele:

; 432  : 		const double mul = dpi / arr->operator [](i).dpi;

	mov	edx, DWORD PTR [ebx]
	fld	QWORD PTR _dpi$[esp+44]
	mov	eax, DWORD PTR tv308[esp+48]
	fdiv	QWORD PTR [eax+edx+32]

; 433  : 		CRect nsel =(CRect)arr->operator [](i);

	mov	ecx, DWORD PTR [eax+edx]
	add	eax, edx
	mov	DWORD PTR _nsel$85593[esp+48], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _nsel$85593[esp+52], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _nsel$85593[esp+56], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _nsel$85593[esp+60], edx
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _nsel$85593[esp+64], ecx
	mov	edx, DWORD PTR [eax+20]
	mov	DWORD PTR _nsel$85593[esp+68], edx

; 434  : 
; 435  : 		nsel.left   = int(nsel.left   * mul);

	fild	DWORD PTR _nsel$85593[esp+48]
	fmul	ST(0), ST(1)
	call	__ftol2_sse

; 436  : 		nsel.top    = int(nsel.top    * mul);

	fild	DWORD PTR _nsel$85593[esp+52]
	mov	DWORD PTR _nsel$85593[esp+48], eax
	fmul	ST(0), ST(1)
	call	__ftol2_sse

; 437  : 		nsel.right  = int(nsel.right  * mul);

	fild	DWORD PTR _nsel$85593[esp+56]
	mov	DWORD PTR _nsel$85593[esp+52], eax
	fmul	ST(0), ST(1)
	call	__ftol2_sse

; 438  : 		nsel.bottom = int(nsel.bottom * mul);

	fimul	DWORD PTR _nsel$85593[esp+60]
	mov	esi, eax
	call	__ftol2_sse

; 439  : 
; 440  : 		// enlarge right/bottom 
; 441  : 		nsel.right++;
; 442  : 		nsel.bottom++;
; 443  : 
; 444  : 		::Rectangle(dc,nsel.left,nsel.top,nsel.right,nsel.bottom);

	mov	ecx, DWORD PTR _nsel$85593[esp+48]
	inc	eax
	push	eax
	inc	esi
	push	esi
	mov	DWORD PTR _nsel$85593[esp+68], eax
	mov	eax, DWORD PTR _nsel$85593[esp+60]
	push	eax
	push	ecx
	push	edi
	mov	DWORD PTR _nsel$85593[esp+76], esi
	call	DWORD PTR __imp__Rectangle@20

; 445  : 		::InvertRect(dc,&nsel);

	lea	edx, DWORD PTR _nsel$85593[esp+48]
	push	edx
	push	edi
	call	DWORD PTR __imp__InvertRect@8
	add	DWORD PTR tv308[esp+48], 40		; 00000028H
	inc	ebp
	cmp	ebp, DWORD PTR [ebx+4]
	jb	$LL16@RenderSele

; 430  : 
; 431  : 	for(int i=0;i<arr->GetCount();i++){

	mov	esi, DWORD PTR __imp__SelectObject@8
$LN1@RenderSele:

; 446  : 	}
; 447  : 	SelectObject(dc,old_pen);

	mov	eax, DWORD PTR _old_pen$[esp+48]
	push	eax
	push	edi
	call	esi

; 448  : 	SelectObject(dc,old_brush);

	mov	ecx, DWORD PTR _old_brush$[esp+48]
	push	ecx
	push	edi
	call	esi
	pop	esi
	pop	ebp
	pop	ebx

; 449  : }

	add	esp, 36					; 00000024H
	ret	8
?RenderSelection@PDFPageInterop@@QAEXNJKKH@Z ENDP	; PDFPageInterop::RenderSelection
_TEXT	ENDS
PUBLIC	?CvtUserToDev@PDFPageInterop@@AAEXHHPAH0@Z	; PDFPageInterop::CvtUserToDev
; Function compile flags: /Ogtpy
;	COMDAT ?CvtUserToDev@PDFPageInterop@@AAEXHHPAH0@Z
_TEXT	SEGMENT
_xu$ = 8						; size = 4
_yu$ = 12						; size = 4
_xd$ = 16						; size = 4
_yd$ = 20						; size = 4
?CvtUserToDev@PDFPageInterop@@AAEXHHPAH0@Z PROC		; PDFPageInterop::CvtUserToDev, COMDAT
; _this$ = esi

; 281  :     *xd = (int)(ctm[0] * xu + ctm[2] * yu + ctm[4] + 0.5);

	fild	DWORD PTR _xu$[esp-4]
	fild	DWORD PTR _yu$[esp-4]
	fld	QWORD PTR [esi+56]
	fmul	ST(0), ST(1)
	fld	QWORD PTR [esi+40]
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fadd	QWORD PTR [esi+72]
	fld	QWORD PTR __real@3fe0000000000000
	fadd	ST(1), ST(0)
	fxch	ST(1)
	call	__ftol2_sse

; 282  :     *yd = (int)(ctm[1] * xu + ctm[3] * yu + ctm[5] + 0.5);

	fld	QWORD PTR [esi+64]
	mov	ecx, DWORD PTR _xd$[esp-4]
	fmulp	ST(2), ST(0)
	fld	QWORD PTR [esi+48]
	mov	DWORD PTR [ecx], eax
	fmulp	ST(3), ST(0)
	fxch	ST(1)
	faddp	ST(2), ST(0)
	fxch	ST(1)
	fadd	QWORD PTR [esi+80]
	faddp	ST(1), ST(0)
	call	__ftol2_sse
	mov	edx, DWORD PTR _yd$[esp-4]
	mov	DWORD PTR [edx], eax

; 283  : }

	ret	16					; 00000010H
?CvtUserToDev@PDFPageInterop@@AAEXHHPAH0@Z ENDP		; PDFPageInterop::CvtUserToDev
_TEXT	ENDS
PUBLIC	?clearSelection@PDFPageInterop@@QAEXXZ		; PDFPageInterop::clearSelection
; Function compile flags: /Ogtpy
;	COMDAT ?clearSelection@PDFPageInterop@@QAEXXZ
_TEXT	SEGMENT
?clearSelection@PDFPageInterop@@QAEXXZ PROC		; PDFPageInterop::clearSelection, COMDAT
; _this$ = eax

; 247  : {

	push	esi

; 248  : 	DynArray<pdfPageSelection> *arr= (DynArray<pdfPageSelection> *)this->_selectionArray;

	mov	esi, DWORD PTR [eax+12]

; 249  : 	arr->Clear();

	mov	ecx, DWORD PTR [esi]
	push	5120					; 00001400H
	push	ecx
	mov	DWORD PTR [esi+4], 0
	call	DWORD PTR __imp__realloc
	add	esp, 8
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+8], 128			; 00000080H
	pop	esi

; 250  : }

	ret	0
?clearSelection@PDFPageInterop@@QAEXXZ ENDP		; PDFPageInterop::clearSelection
_TEXT	ENDS
PUBLIC	?getTextWordBox@PDFPageInterop@@QAEXHHPAH000@Z	; PDFPageInterop::getTextWordBox
; Function compile flags: /Ogtpy
;	COMDAT ?getTextWordBox@PDFPageInterop@@QAEXHHPAH000@Z
_TEXT	SEGMENT
?getTextWordBox@PDFPageInterop@@QAEXHHPAH000@Z PROC	; PDFPageInterop::getTextWordBox, COMDAT

; 240  : }

	ret	0
?getTextWordBox@PDFPageInterop@@QAEXHHPAH000@Z ENDP	; PDFPageInterop::getTextWordBox
_TEXT	ENDS
PUBLIC	?getTextCharBox@PDFPageInterop@@QAEXHHPAH000@Z	; PDFPageInterop::getTextCharBox
; Function compile flags: /Ogtpy
;	COMDAT ?getTextCharBox@PDFPageInterop@@QAEXHHPAH000@Z
_TEXT	SEGMENT
?getTextCharBox@PDFPageInterop@@QAEXHHPAH000@Z PROC	; PDFPageInterop::getTextCharBox, COMDAT

; 237  : }

	ret	0
?getTextCharBox@PDFPageInterop@@QAEXHHPAH000@Z ENDP	; PDFPageInterop::getTextCharBox
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GGString@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GGString@@QAEPAXI@Z PROC				; GString::`scalar deleting destructor', COMDAT
; _this$ = esi
	mov	ecx, esi
	call	??1GString@@QAE@XZ			; GString::~GString
	test	BYTE PTR ___flags$[esp-4], 1
	je	SHORT $LN4@scalar@3
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@3:
	mov	eax, esi
	ret	4
??_GGString@@QAEPAXI@Z ENDP				; GString::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?extractText@PDFPageInterop@@QAEPA_WXZ		; PDFPageInterop::extractText
; Function compile flags: /Ogtpy
;	COMDAT ?extractText@PDFPageInterop@@QAEPA_WXZ
_TEXT	SEGMENT
?extractText@PDFPageInterop@@QAEPA_WXZ PROC		; PDFPageInterop::extractText, COMDAT

; 118  : #ifdef PDFLIBNET_ORIGINAL
; 119  : 	CString str;
; 120  : 	DynArray<pdfPageSelection> *arr =(DynArray<pdfPageSelection> *)this->_selectionArray;
; 121  : 	char *buf;
; 122  : 	size_t bytes_c;
; 123  : 	int bufSize=4096;
; 124  : 	for(int i=0; i<arr->GetSize();++i){
; 125  : 		str.AppendChar('\n');
; 126  : 		wchar_t *txt =((pdfPageSelection)arr->operator [](i)).text;
; 127  : 		bufSize = wcslen(txt);
; 128  : 		buf = (char *)malloc(bufSize+2);
; 129  : 		wcstombs_s(&bytes_c,buf,bufSize,txt,bufSize);
; 130  : 		
; 131  : 		if(buf){
; 132  : 			str.Append(buf);
; 133  : 			free(buf);
; 134  : 		}
; 135  : 	}
; 136  : 	return str.AllocSysString();
; 137  : #else
; 138  : 	return EmptyChar;

	mov	eax, OFFSET _EmptyChar

; 139  : #endif
; 140  : }

	ret	0
?extractText@PDFPageInterop@@QAEPA_WXZ ENDP		; PDFPageInterop::extractText
_TEXT	ENDS
PUBLIC	?getPage@PDFPageInterop@@QAEHXZ			; PDFPageInterop::getPage
; Function compile flags: /Ogtpy
;	COMDAT ?getPage@PDFPageInterop@@QAEHXZ
_TEXT	SEGMENT
?getPage@PDFPageInterop@@QAEHXZ PROC			; PDFPageInterop::getPage, COMDAT
; _this$ = ecx

; 113  : 	return _page;

	mov	eax, DWORD PTR [ecx+32]

; 114  : }

	ret	0
?getPage@PDFPageInterop@@QAEHXZ ENDP			; PDFPageInterop::getPage
_TEXT	ENDS
PUBLIC	?getImageHeight@PDFPageInterop@@QAEHH@Z		; PDFPageInterop::getImageHeight
; Function compile flags: /Ogtpy
;	COMDAT ?getImageHeight@PDFPageInterop@@QAEHH@Z
_TEXT	SEGMENT
_index$ = 8						; size = 4
?getImageHeight@PDFPageInterop@@QAEHH@Z PROC		; PDFPageInterop::getImageHeight, COMDAT
; _this$ = ecx

; 96   : 	if(_images)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN1@getImageHe@2

; 97   : 		return ((ImagesMemoryOutputDev *)_images)->getImageHeight(index);

	mov	eax, DWORD PTR _index$[esp-4]
	test	eax, eax
	jl	SHORT $LN1@getImageHe@2
	cmp	eax, DWORD PTR [ecx+108]
	jae	SHORT $LN1@getImageHe@2
	mov	ecx, DWORD PTR [ecx+104]
	lea	eax, DWORD PTR [eax+eax*8]
	mov	eax, DWORD PTR [ecx+eax*4+12]

; 99   : }

	ret	4
$LN1@getImageHe@2:

; 98   : 	return 0;

	xor	eax, eax

; 99   : }

	ret	4
?getImageHeight@PDFPageInterop@@QAEHH@Z ENDP		; PDFPageInterop::getImageHeight
_TEXT	ENDS
PUBLIC	?getImageNumComps@PDFPageInterop@@QAEHH@Z	; PDFPageInterop::getImageNumComps
; Function compile flags: /Ogtpy
;	COMDAT ?getImageNumComps@PDFPageInterop@@QAEHH@Z
_TEXT	SEGMENT
_index$ = 8						; size = 4
?getImageNumComps@PDFPageInterop@@QAEHH@Z PROC		; PDFPageInterop::getImageNumComps, COMDAT
; _this$ = ecx

; 90   : 	if(_images)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN1@getImageNu@2

; 91   : 		return ((ImagesMemoryOutputDev *)_images)->getImageNumComps(index);

	mov	eax, DWORD PTR _index$[esp-4]
	test	eax, eax
	jl	SHORT $LN1@getImageNu@2
	cmp	eax, DWORD PTR [ecx+108]
	jae	SHORT $LN1@getImageNu@2
	mov	ecx, DWORD PTR [ecx+104]
	lea	eax, DWORD PTR [eax+eax*8]
	mov	eax, DWORD PTR [ecx+eax*4+28]

; 93   : }

	ret	4
$LN1@getImageNu@2:

; 92   : 	return 0;

	xor	eax, eax

; 93   : }

	ret	4
?getImageNumComps@PDFPageInterop@@QAEHH@Z ENDP		; PDFPageInterop::getImageNumComps
_TEXT	ENDS
PUBLIC	?getImageWidth@PDFPageInterop@@QAEHH@Z		; PDFPageInterop::getImageWidth
; Function compile flags: /Ogtpy
;	COMDAT ?getImageWidth@PDFPageInterop@@QAEHH@Z
_TEXT	SEGMENT
_index$ = 8						; size = 4
?getImageWidth@PDFPageInterop@@QAEHH@Z PROC		; PDFPageInterop::getImageWidth, COMDAT
; _this$ = ecx

; 84   : 	if(_images)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN1@getImageWi@2

; 85   : 		return ((ImagesMemoryOutputDev *)_images)->getImageWidth(index);

	mov	eax, DWORD PTR _index$[esp-4]
	test	eax, eax
	jl	SHORT $LN1@getImageWi@2
	cmp	eax, DWORD PTR [ecx+108]
	jae	SHORT $LN1@getImageWi@2
	mov	ecx, DWORD PTR [ecx+104]
	lea	eax, DWORD PTR [eax+eax*8]
	mov	eax, DWORD PTR [ecx+eax*4+8]

; 87   : }

	ret	4
$LN1@getImageWi@2:

; 86   : 	return 0;

	xor	eax, eax

; 87   : }

	ret	4
?getImageWidth@PDFPageInterop@@QAEHH@Z ENDP		; PDFPageInterop::getImageWidth
_TEXT	ENDS
PUBLIC	?getImageType@PDFPageInterop@@QAEHH@Z		; PDFPageInterop::getImageType
; Function compile flags: /Ogtpy
;	COMDAT ?getImageType@PDFPageInterop@@QAEHH@Z
_TEXT	SEGMENT
_index$ = 8						; size = 4
?getImageType@PDFPageInterop@@QAEHH@Z PROC		; PDFPageInterop::getImageType, COMDAT
; _this$ = ecx

; 79   : 	if(_images)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN1@getImageTy@2

; 80   : 		return ((ImagesMemoryOutputDev *)_images)->getImageType(index);

	mov	eax, DWORD PTR _index$[esp-4]
	test	eax, eax
	jl	SHORT $LN4@getImageTy@2
	cmp	eax, DWORD PTR [ecx+108]
	jae	SHORT $LN4@getImageTy@2
	mov	ecx, DWORD PTR [ecx+104]
	lea	eax, DWORD PTR [eax+eax*8]
	mov	eax, DWORD PTR [ecx+eax*4+20]

; 82   : }

	ret	4

; 80   : 		return ((ImagesMemoryOutputDev *)_images)->getImageType(index);

$LN4@getImageTy@2:
	or	eax, -1

; 82   : }

	ret	4
$LN1@getImageTy@2:

; 81   : 	return 0;

	xor	eax, eax

; 82   : }

	ret	4
?getImageType@PDFPageInterop@@QAEHH@Z ENDP		; PDFPageInterop::getImageType
_TEXT	ENDS
PUBLIC	?getImageSize@PDFPageInterop@@QAEHH@Z		; PDFPageInterop::getImageSize
; Function compile flags: /Ogtpy
;	COMDAT ?getImageSize@PDFPageInterop@@QAEHH@Z
_TEXT	SEGMENT
_index$ = 8						; size = 4
?getImageSize@PDFPageInterop@@QAEHH@Z PROC		; PDFPageInterop::getImageSize, COMDAT
; _this$ = ecx

; 74   : 	if(_images)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN1@getImageSi@2

; 75   : 		return ((ImagesMemoryOutputDev *)_images)->getImageSize(index);

	mov	eax, DWORD PTR _index$[esp-4]
	test	eax, eax
	jl	SHORT $LN1@getImageSi@2
	cmp	eax, DWORD PTR [ecx+108]
	jae	SHORT $LN1@getImageSi@2
	mov	ecx, DWORD PTR [ecx+104]
	lea	eax, DWORD PTR [eax+eax*8]
	mov	eax, DWORD PTR [ecx+eax*4+24]

; 77   : }

	ret	4
$LN1@getImageSi@2:

; 76   : 	return 0;

	xor	eax, eax

; 77   : }

	ret	4
?getImageSize@PDFPageInterop@@QAEHH@Z ENDP		; PDFPageInterop::getImageSize
_TEXT	ENDS
PUBLIC	?getImageBytes@PDFPageInterop@@QAEPAEH@Z	; PDFPageInterop::getImageBytes
; Function compile flags: /Ogtpy
;	COMDAT ?getImageBytes@PDFPageInterop@@QAEPAEH@Z
_TEXT	SEGMENT
_index$ = 8						; size = 4
?getImageBytes@PDFPageInterop@@QAEPAEH@Z PROC		; PDFPageInterop::getImageBytes, COMDAT
; _this$ = ecx

; 69   : 	if(_images)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN1@getImageBy@2

; 70   : 		return ((ImagesMemoryOutputDev *)_images)->getImageBytes(index);

	mov	eax, DWORD PTR _index$[esp-4]
	test	eax, eax
	jl	SHORT $LN1@getImageBy@2
	cmp	eax, DWORD PTR [ecx+108]
	jae	SHORT $LN1@getImageBy@2
	mov	ecx, DWORD PTR [ecx+104]
	lea	eax, DWORD PTR [eax+eax*8]
	mov	eax, DWORD PTR [ecx+eax*4]

; 72   : }

	ret	4
$LN1@getImageBy@2:

; 71   : 	return 0;

	xor	eax, eax

; 72   : }

	ret	4
?getImageBytes@PDFPageInterop@@QAEPAEH@Z ENDP		; PDFPageInterop::getImageBytes
_TEXT	ENDS
PUBLIC	?getImagesCount@PDFPageInterop@@QAEHXZ		; PDFPageInterop::getImagesCount
; Function compile flags: /Ogtpy
;	COMDAT ?getImagesCount@PDFPageInterop@@QAEHXZ
_TEXT	SEGMENT
?getImagesCount@PDFPageInterop@@QAEHXZ PROC		; PDFPageInterop::getImagesCount, COMDAT
; _this$ = ecx

; 64   : 	if(_images)

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN1@getImagesC

; 65   : 		return ((ImagesMemoryOutputDev *)_images)->getImageCount();

	mov	eax, DWORD PTR [eax+108]

; 67   : }

	ret	0
$LN1@getImagesC:

; 66   : 	return 0;

	xor	eax, eax

; 67   : }

	ret	0
?getImagesCount@PDFPageInterop@@QAEHXZ ENDP		; PDFPageInterop::getImagesCount
_TEXT	ENDS
PUBLIC	??1PDFPageInterop@@QAE@XZ			; PDFPageInterop::~PDFPageInterop
; Function compile flags: /Ogtpy
;	COMDAT ??1PDFPageInterop@@QAE@XZ
_TEXT	SEGMENT
??1PDFPageInterop@@QAE@XZ PROC				; PDFPageInterop::~PDFPageInterop, COMDAT
; _this$ = ecx

; 56   : {

	push	esi
	mov	esi, ecx

; 57   : 	if(_text)

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN2@PDFPageInt

; 58   : 		delete _text;

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN2@PDFPageInt:

; 59   : 	if(_images)

	mov	esi, DWORD PTR [esi]
	test	esi, esi
	je	SHORT $LN1@PDFPageInt

; 60   : 		delete _images;

	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@PDFPageInt:
	pop	esi

; 61   : }

	ret	0
??1PDFPageInterop@@QAE@XZ ENDP				; PDFPageInterop::~PDFPageInterop
_TEXT	ENDS
PUBLIC	??0PDFPageInterop@@QAE@HPAX0@Z			; PDFPageInterop::PDFPageInterop
;	COMDAT xdata$x
; File c:\projects\pdflibnet\libafpdflib\dynarray.h
xdata$x	SEGMENT
__unwindtable$??0PDFPageInterop@@QAE@HPAX0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0PDFPageInterop@@QAE@HPAX0@Z$0
__ehfuncinfo$??0PDFPageInterop@@QAE@HPAX0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0PDFPageInterop@@QAE@HPAX0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\projects\pdflibnet\libafpdflib\pdfpageinterop.cpp
xdata$x	ENDS
;	COMDAT ??0PDFPageInterop@@QAE@HPAX0@Z
_TEXT	SEGMENT
$T161322 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_page$ = 8						; size = 4
$T161331 = 12						; size = 4
_pdfDoc$ = 12						; size = 4
??0PDFPageInterop@@QAE@HPAX0@Z PROC			; PDFPageInterop::PDFPageInterop, COMDAT
; _this$ = esi
; _lptr$ = ecx

; 53   : {

	push	-1
	push	__ehhandler$??0PDFPageInterop@@QAE@HPAX0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, eax
	mov	eax, DWORD PTR _pdfDoc$[esp+24]
	xor	ebx, ebx
	push	12					; 0000000cH
	mov	DWORD PTR [esi], ebx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], ecx
	call	??2@YAPAXI@Z				; operator new
	mov	edi, eax
	add	esp, 4
	mov	DWORD PTR $T161322[esp+28], edi
	mov	DWORD PTR __$EHRec$[esp+36], ebx
	cmp	edi, ebx
	je	SHORT $LN3@PDFPageInt@2
	push	5120					; 00001400H
	mov	DWORD PTR [edi+8], 128			; 00000080H
	mov	DWORD PTR [edi+4], ebx
	call	DWORD PTR __imp__malloc
	add	esp, 4
	mov	DWORD PTR [edi], eax
	cmp	eax, ebx
	jne	SHORT $LN4@PDFPageInt@2
	push	OFFSET __TI1?AW4exception@?$DynArray@VpdfPageSelection@@@@
	lea	edx, DWORD PTR $T161331[esp+28]
	push	edx
	mov	DWORD PTR $T161331[esp+32], ebx
	call	__CxxThrowException@8
$LN12@PDFPageInt@2:
$LN3@PDFPageInt@2:
	xor	edi, edi
$LN4@PDFPageInt@2:
	fldz
	mov	eax, DWORD PTR _page$[esp+24]
	fst	QWORD PTR [esi+24]
	mov	DWORD PTR [esi+32], eax
	fstp	QWORD PTR [esi+88]
	mov	DWORD PTR [esi+12], edi
	mov	DWORD PTR [esi+16], ebx

; 54   : }

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	ebx
	add	esp, 16					; 00000010H
	ret	8
$LN11@PDFPageInt@2:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0PDFPageInterop@@QAE@HPAX0@Z$0:
	mov	eax, DWORD PTR $T161322[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$??0PDFPageInterop@@QAE@HPAX0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0PDFPageInterop@@QAE@HPAX0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0PDFPageInterop@@QAE@HPAX0@Z ENDP			; PDFPageInterop::PDFPageInterop
PUBLIC	?UTF8translate@@YAPA_WQAD@Z			; UTF8translate
; Function compile flags: /Ogtpy
;	COMDAT ?UTF8translate@@YAPA_WQAD@Z
_TEXT	SEGMENT
_artist$ = 8						; size = 4
?UTF8translate@@YAPA_WQAD@Z PROC			; UTF8translate, COMDAT

; 13   : {

	push	ebx

; 14   : 	int nNeeded = MultiByteToWideChar( CP_UTF8, NULL, artist, -1, 0, 0 );

	mov	ebx, DWORD PTR __imp__MultiByteToWideChar@24
	push	ebp
	mov	ebp, DWORD PTR _artist$[esp+4]
	push	esi
	push	0
	push	0
	push	-1
	push	ebp
	push	0
	push	65001					; 0000fde9H
	call	ebx
	mov	esi, eax

; 15   : 	if( !nNeeded )

	test	esi, esi
	jne	SHORT $LN2@UTF8transl
	pop	esi
	pop	ebp
	pop	ebx

; 28   : }

	ret	0
$LN2@UTF8transl:

; 16   : 	{
; 17   : 		return NULL;
; 18   : 	}
; 19   :  
; 20   : 	wchar_t* pWideChar = new wchar_t[nNeeded + 1];

	xor	ecx, ecx
	lea	eax, DWORD PTR [esi+1]
	mov	edx, 2
	mul	edx
	seto	cl
	push	edi
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4

; 21   : 	if( !MultiByteToWideChar( CP_UTF8, NULL, artist, -1, pWideChar, nNeeded ))

	push	esi
	mov	edi, eax
	push	edi
	push	-1
	push	ebp
	push	0
	push	65001					; 0000fde9H
	call	ebx
	test	eax, eax
	jne	SHORT $LN1@UTF8transl

; 22   : 	{
; 23   : 		delete[] pWideChar;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebp

; 24   : 		return NULL;

	xor	eax, eax
	pop	ebx

; 28   : }

	ret	0
$LN1@UTF8transl:

; 25   : 	}
; 26   : 	
; 27   : 	return pWideChar;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 28   : }

	ret	0
?UTF8translate@@YAPA_WQAD@Z ENDP			; UTF8translate
; Function compile flags: /Ogtpy
; File c:\projects\pdflibnet\libafpdflib\crect.h
_TEXT	ENDS
;	COMDAT ??0CRect@@QAE@HHHH@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
??0CRect@@QAE@HHHH@Z PROC				; CRect::CRect, COMDAT
; _this$ = eax
; _y$ = esi
; _r$ = edx
; _b$ = ecx

; 8    : 	CRect(int x, int y, int r, int b){

	push	ebx
	push	edi
	mov	edi, DWORD PTR _x$[esp+4]

; 9    : 		left=x;

	mov	DWORD PTR [eax], edi

; 10   : 		top=y;
; 11   : 		width = r - x;

	mov	ebx, edx
	sub	ebx, edi

; 12   : 		height = b - y;

	mov	edi, ecx
	sub	edi, esi
	mov	DWORD PTR [eax+20], edi
	pop	edi
	mov	DWORD PTR [eax+16], ebx
	mov	DWORD PTR [eax+4], esi

; 13   : 		right = r;

	mov	DWORD PTR [eax+8], edx

; 14   : 		bottom = b;

	mov	DWORD PTR [eax+12], ecx
	pop	ebx

; 15   : 	}

	ret	4
??0CRect@@QAE@HHHH@Z ENDP				; CRect::CRect
; Function compile flags: /Ogtpy
; File c:\projects\pdflibnet\xpdfwin\xpdf\page.h
_TEXT	ENDS
;	COMDAT ?getRotate@PageAttrs@@QAEHXZ
_TEXT	SEGMENT
?getRotate@PageAttrs@@QAEHXZ PROC			; PageAttrs::getRotate, COMDAT
; _this$ = eax

; 61   :   int getRotate() { return rotate; }

	mov	eax, DWORD PTR [eax+168]
	ret	0
?getRotate@PageAttrs@@QAEHXZ ENDP			; PageAttrs::getRotate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getCropBox@PageAttrs@@QAEPAVPDFRectangle@@XZ
_TEXT	SEGMENT
?getCropBox@PageAttrs@@QAEPAVPDFRectangle@@XZ PROC	; PageAttrs::getCropBox, COMDAT
; _this$ = eax

; 56   :   PDFRectangle *getCropBox() { return &cropBox; }

	add	eax, 32					; 00000020H
	ret	0
?getCropBox@PageAttrs@@QAEPAVPDFRectangle@@XZ ENDP	; PageAttrs::getCropBox
; Function compile flags: /Ogtpy
; File c:\projects\pdflibnet\xpdfwin\goo\gstring.h
_TEXT	ENDS
;	COMDAT ?getChar@GString@@QAEDH@Z
_TEXT	SEGMENT
?getChar@GString@@QAEDH@Z PROC				; GString::getChar, COMDAT
; _this$ = eax
; _i$ = edx

; 83   :   char getChar(int i) { return s[i]; }

	mov	ecx, DWORD PTR [eax+4]
	mov	al, BYTE PTR [edx+ecx]
	ret	0
?getChar@GString@@QAEDH@Z ENDP				; GString::getChar
; Function compile flags: /Ogtpy
; File c:\projects\pdflibnet\libafpdflib\pdfpageinterop.cpp
;	COMDAT ??0pdfPageSelection@@QAE@PA_WNHHHH@Z
_TEXT	SEGMENT
_DPI$ = 8						; size = 8
_w$ = 16						; size = 4
_h$ = 20						; size = 4
??0pdfPageSelection@@QAE@PA_WNHHHH@Z PROC		; pdfPageSelection::pdfPageSelection, COMDAT
; _this$ = eax
; _x$ = edx
; _y$ = ecx

; 40   : 	{

	fld	QWORD PTR _DPI$[esp-4]
	push	ebx
	push	esi
	fstp	QWORD PTR [eax+32]
	mov	esi, DWORD PTR _h$[esp+4]
	push	edi
	mov	edi, DWORD PTR _w$[esp+8]
	add	edi, edx
	add	esi, ecx
	mov	ebx, edi
	sub	ebx, edx
	mov	DWORD PTR [eax], edx
	mov	edx, esi
	mov	DWORD PTR [eax+8], edi
	pop	edi
	mov	DWORD PTR [eax+12], esi
	sub	edx, ecx
	pop	esi
	mov	DWORD PTR [eax+16], ebx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+20], edx
	mov	DWORD PTR [eax+24], 0
	pop	ebx

; 41   : 	}

	ret	16					; 00000010H
??0pdfPageSelection@@QAE@PA_WNHHHH@Z ENDP		; pdfPageSelection::pdfPageSelection
; Function compile flags: /Ogtpy
; File c:\projects\pdflibnet\xpdfwin\xpdf\page.h
_TEXT	ENDS
;	COMDAT ?getRotate@Page@@QAEHXZ
_TEXT	SEGMENT
?getRotate@Page@@QAEHXZ PROC				; Page::getRotate, COMDAT
; _this$ = eax

; 131  :   int getRotate() { return attrs->getRotate(); }

	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [ecx+168]
	ret	0
?getRotate@Page@@QAEHXZ ENDP				; Page::getRotate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getCropHeight@Page@@QAENXZ
_TEXT	SEGMENT
?getCropHeight@Page@@QAENXZ PROC			; Page::getCropHeight, COMDAT
; _this$ = eax

; 127  :     { return attrs->getCropBox()->y2 - attrs->getCropBox()->y1; }

	mov	eax, DWORD PTR [eax+8]
	fld	QWORD PTR [eax+56]
	fsub	QWORD PTR [eax+40]
	ret	0
?getCropHeight@Page@@QAENXZ ENDP			; Page::getCropHeight
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getCropWidth@Page@@QAENXZ
_TEXT	SEGMENT
?getCropWidth@Page@@QAENXZ PROC				; Page::getCropWidth, COMDAT
; _this$ = eax

; 125  :     { return attrs->getCropBox()->x2 - attrs->getCropBox()->x1; }

	mov	eax, DWORD PTR [eax+8]
	fld	QWORD PTR [eax+48]
	fsub	QWORD PTR [eax+32]
	ret	0
?getCropWidth@Page@@QAENXZ ENDP				; Page::getCropWidth
; Function compile flags: /Ogtpy
; File c:\projects\pdflibnet\libafpdflib\pdfpageinterop.cpp
;	COMDAT ?WriteToGString@@YAXPAXPADH@Z
_TEXT	SEGMENT
_stream$ = 8						; size = 4
_str$ = 12						; size = 4
_len$ = 16						; size = 4
?WriteToGString@@YAXPAXPADH@Z PROC			; WriteToGString, COMDAT

; 287  : 	GString *gstr =(GString *)stream;
; 288  : 	gstr->append(str,len);

	mov	eax, DWORD PTR _len$[esp-4]
	mov	ecx, DWORD PTR _str$[esp-4]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _stream$[esp+4]
	call	?append@GString@@QAEPAV1@PBDH@Z		; GString::append

; 289  : }

	ret	0
?WriteToGString@@YAXPAXPADH@Z ENDP			; WriteToGString
_TEXT	ENDS
PUBLIC	?addSelection@PDFPageInterop@@QAEXNHHHH@Z	; PDFPageInterop::addSelection
; Function compile flags: /Ogtpy
;	COMDAT ?addSelection@PDFPageInterop@@QAEXNHHHH@Z
_TEXT	SEGMENT
_dpi$ = 8						; size = 8
_arr$ = 16						; size = 4
_x1$ = 16						; size = 4
?addSelection@PDFPageInterop@@QAEXNHHHH@Z PROC		; PDFPageInterop::addSelection, COMDAT
; _this$ = eax
; _y1$ = ebx
; _x2$ = edi
; _y2$ = esi

; 243  : 	DynArray<pdfPageSelection> *arr= (DynArray<pdfPageSelection> *)this->_selectionArray;

	mov	ecx, DWORD PTR [eax+12]
	push	ebp
	mov	ebp, DWORD PTR _x1$[esp]

; 244  : 	arr->Add(*(new pdfPageSelection(NULL,dpi,x1,y1,x2-x1,y2-y1)));

	push	40					; 00000028H
	mov	DWORD PTR _arr$[esp+4], ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@addSelecti
	fld	QWORD PTR _dpi$[esp]
	mov	edx, edi
	mov	ecx, esi
	fstp	QWORD PTR [eax+32]
	sub	edx, ebp
	sub	ecx, ebx
	mov	DWORD PTR [eax], ebp
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+16], edx
	mov	DWORD PTR [eax+20], ecx
	mov	DWORD PTR [eax+8], edi
	mov	DWORD PTR [eax+12], esi
	mov	DWORD PTR [eax+24], 0
	push	eax
	mov	eax, DWORD PTR _arr$[esp+4]
	call	?Add@?$DynArray@VpdfPageSelection@@@@QAEXABVpdfPageSelection@@@Z ; DynArray<pdfPageSelection>::Add
	pop	ebp

; 245  : }

	ret	12					; 0000000cH
$LN3@addSelecti:

; 244  : 	arr->Add(*(new pdfPageSelection(NULL,dpi,x1,y1,x2-x1,y2-y1)));

	xor	eax, eax
	push	eax
	mov	eax, DWORD PTR _arr$[esp+4]
	call	?Add@?$DynArray@VpdfPageSelection@@@@QAEXABVpdfPageSelection@@@Z ; DynArray<pdfPageSelection>::Add
	pop	ebp

; 245  : }

	ret	12					; 0000000cH
?addSelection@PDFPageInterop@@QAEXNHHHH@Z ENDP		; PDFPageInterop::addSelection
; Function compile flags: /Ogtpy
; File c:\projects\pdflibnet\xpdfwin\xpdf\pdfdoc.h
_TEXT	ENDS
;	COMDAT ?getPageRotate@PDFDoc@@QAEHH@Z
_TEXT	SEGMENT
_page$ = 8						; size = 4
?getPageRotate@PDFDoc@@QAEHH@Z PROC			; PDFDoc::getPageRotate, COMDAT
; _this$ = eax

; 76   :     { return catalog->getPage(page)->getRotate(); }

	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _page$[esp-4]
	mov	ecx, DWORD PTR [edx+eax*4-4]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+168]
	ret	4
?getPageRotate@PDFDoc@@QAEHH@Z ENDP			; PDFDoc::getPageRotate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getPageCropHeight@PDFDoc@@QAENH@Z
_TEXT	SEGMENT
_page$ = 8						; size = 4
?getPageCropHeight@PDFDoc@@QAENH@Z PROC			; PDFDoc::getPageCropHeight, COMDAT
; _this$ = eax

; 74   :     { return catalog->getPage(page)->getCropHeight(); }

	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _page$[esp-4]
	mov	eax, DWORD PTR [edx+eax*4-4]
	mov	eax, DWORD PTR [eax+8]
	fld	QWORD PTR [eax+56]
	fsub	QWORD PTR [eax+40]
	ret	4
?getPageCropHeight@PDFDoc@@QAENH@Z ENDP			; PDFDoc::getPageCropHeight
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getPageCropWidth@PDFDoc@@QAENH@Z
_TEXT	SEGMENT
_page$ = 8						; size = 4
?getPageCropWidth@PDFDoc@@QAENH@Z PROC			; PDFDoc::getPageCropWidth, COMDAT
; _this$ = eax

; 72   :     { return catalog->getPage(page)->getCropWidth(); }

	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _page$[esp-4]
	mov	eax, DWORD PTR [edx+eax*4-4]
	mov	eax, DWORD PTR [eax+8]
	fld	QWORD PTR [eax+48]
	fsub	QWORD PTR [eax+32]
	ret	4
?getPageCropWidth@PDFDoc@@QAENH@Z ENDP			; PDFDoc::getPageCropWidth
PUBLIC	__real@406fc00000000000
PUBLIC	?getPageHeight@PDFPageInterop@@QAENXZ		; PDFPageInterop::getPageHeight
;	COMDAT __real@406fc00000000000
; File c:\projects\pdflibnet\xpdfwin\xpdf\page.h
CONST	SEGMENT
__real@406fc00000000000 DQ 0406fc00000000000r	; 254
; Function compile flags: /Ogtpy
; File c:\projects\pdflibnet\libafpdflib\pdfpageinterop.cpp
CONST	ENDS
;	COMDAT ?getPageHeight@PDFPageInterop@@QAENXZ
_TEXT	SEGMENT
?getPageHeight@PDFPageInterop@@QAENXZ PROC		; PDFPageInterop::getPageHeight, COMDAT
; _this$ = ecx

; 413  : 	AFPDFDoc *doc = (AFPDFDoc *)_pdfDoc;
; 414  :     double h = doc->getDoc()->getPageCropHeight(_page);

	mov	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR [eax+332]
	mov	eax, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [edx+ecx*4-4]
	mov	eax, DWORD PTR [eax+8]
	fld	QWORD PTR [eax+56]
	fsub	QWORD PTR [eax+40]

; 415  :     
; 416  : 	return 254*h/72;

	fmul	QWORD PTR __real@406fc00000000000
	fdiv	QWORD PTR __real@4052000000000000

; 417  : }

	ret	0
?getPageHeight@PDFPageInterop@@QAENXZ ENDP		; PDFPageInterop::getPageHeight
_TEXT	ENDS
PUBLIC	?getPageRotate@PDFPageInterop@@QAEHXZ		; PDFPageInterop::getPageRotate
; Function compile flags: /Ogtpy
;	COMDAT ?getPageRotate@PDFPageInterop@@QAEHXZ
_TEXT	SEGMENT
?getPageRotate@PDFPageInterop@@QAEHXZ PROC		; PDFPageInterop::getPageRotate, COMDAT
; _this$ = ecx

; 408  : 	AFPDFDoc *doc = (AFPDFDoc *)_pdfDoc;
; 409  :     int r = doc->getDoc()->getPageRotate(_page);
; 410  : 	return r;

	mov	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR [eax+332]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR [ecx+32]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [edx+ecx*4-4]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [ecx+168]

; 411  : }

	ret	0
?getPageRotate@PDFPageInterop@@QAEHXZ ENDP		; PDFPageInterop::getPageRotate
_TEXT	ENDS
PUBLIC	__real@400451eb851eb852
PUBLIC	__real@40bc200000000000
PUBLIC	__real@4088c00000000000
PUBLIC	__real@4083200000000000
PUBLIC	?getISOANum@PDFPageInterop@@QAEPADXZ		; PDFPageInterop::getISOANum
;	COMDAT __real@400451eb851eb852
; File c:\projects\pdflibnet\xpdfwin\xpdf\page.h
CONST	SEGMENT
__real@400451eb851eb852 DQ 0400451eb851eb852r	; 2.54
CONST	ENDS
;	COMDAT __real@40bc200000000000
CONST	SEGMENT
__real@40bc200000000000 DQ 040bc200000000000r	; 7200
CONST	ENDS
;	COMDAT __real@4088c00000000000
CONST	SEGMENT
__real@4088c00000000000 DQ 04088c00000000000r	; 792
CONST	ENDS
;	COMDAT __real@4083200000000000
CONST	SEGMENT
__real@4083200000000000 DQ 04083200000000000r	; 612
; Function compile flags: /Ogtpy
; File c:\projects\pdflibnet\libafpdflib\pdfpageinterop.cpp
CONST	ENDS
;	COMDAT ?getISOANum@PDFPageInterop@@QAEPADXZ
_TEXT	SEGMENT
_h$ = -24						; size = 8
_w$ = -16						; size = 8
tv276 = -8						; size = 8
?getISOANum@PDFPageInterop@@QAEPADXZ PROC		; PDFPageInterop::getISOANum, COMDAT
; _this$ = ecx

; 377  : char *PDFPageInterop::getISOANum(){

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 28					; 0000001cH

; 378  : 	AFPDFDoc *doc = (AFPDFDoc *)_pdfDoc;

	mov	eax, DWORD PTR [ecx+4]

; 379  : 	double wISO, hISO;
; 380  : 	double w = doc->getDoc()->getPageCropWidth(_page);

	mov	eax, DWORD PTR [eax+332]
	mov	edx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [ecx+32]
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4-4]
	mov	ecx, DWORD PTR [eax+8]
	fld	QWORD PTR [ecx+48]

; 381  :     double h = doc->getDoc()->getPageCropHeight(_page);

	mov	eax, ecx
	fsub	QWORD PTR [ecx+32]
	push	esi

; 382  :     char *iso=new char[64];

	push	64					; 00000040H
	fstp	QWORD PTR _w$[esp+36]
	fld	QWORD PTR [eax+56]
	fsub	QWORD PTR [eax+40]
	fstp	QWORD PTR _h$[esp+36]
	call	??_U@YAPAXI@Z				; operator new[]

; 383  : 
; 384  : 	if ((fabs(w - 612) < 0.1 && fabs(h - 792) < 0.1) ||	(fabs(w - 792) < 0.1 && fabs(h - 612) < 0.1)) {

	fld	QWORD PTR _w$[esp+36]
	mov	esi, eax
	fld	ST(0)
	add	esp, 4
	fld	QWORD PTR __real@4083200000000000
	fsub	ST(1), ST(0)
	fxch	ST(1)
	fabs
	fld	QWORD PTR __real@3fb999999999999a
	fcom	ST(1)
	fnstsw	ax
	fstp	ST(1)
	fld	QWORD PTR __real@4088c00000000000
	test	ah, 65					; 00000041H
	jne	SHORT $LN8@getISOANum
	fld	QWORD PTR _h$[esp+32]
	fsub	ST(0), ST(1)
	fabs
	fcomp	ST(2)
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN44@getISOANum
$LN8@getISOANum:
	fsubp	ST(3), ST(0)
	fxch	ST(2)
	fabs
	fcomp	ST(2)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN48@getISOANum
	fsubr	QWORD PTR _h$[esp+32]
	fabs
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN10@getISOANum

; 385  : 		//Letter page Size
; 386  : 		delete iso;

	push	esi
	call	??3@YAXPAX@Z				; operator delete

; 387  : 		return "letter";

	mov	eax, OFFSET ??_C@_06MNKGPLIC@letter?$AA@

; 399  : 		}
; 400  : 	}
; 401  : 	delete iso;

	add	esp, 4

; 404  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN44@getISOANum:

; 383  : 
; 384  : 	if ((fabs(w - 612) < 0.1 && fabs(h - 792) < 0.1) ||	(fabs(w - 792) < 0.1 && fabs(h - 612) < 0.1)) {

	fstp	ST(1)

; 385  : 		//Letter page Size
; 386  : 		delete iso;

	push	esi
	fstp	ST(2)
	fstp	ST(1)
	fstp	ST(0)
	call	??3@YAXPAX@Z				; operator delete

; 387  : 		return "letter";

	mov	eax, OFFSET ??_C@_06MNKGPLIC@letter?$AA@

; 399  : 		}
; 400  : 	}
; 401  : 	delete iso;

	add	esp, 4

; 404  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN48@getISOANum:

; 383  : 
; 384  : 	if ((fabs(w - 612) < 0.1 && fabs(h - 792) < 0.1) ||	(fabs(w - 792) < 0.1 && fabs(h - 612) < 0.1)) {

	fstp	ST(1)
	fstp	ST(0)
$LN10@getISOANum:

; 388  : 	} else {
; 389  : 		//ISO A page Size
; 390  : 		hISO = sqrt(sqrt(2.0)) * 7200 / 2.54;

	fld	QWORD PTR __real@4000000000000000
	call	__CIsqrt
	fst	QWORD PTR tv276[esp+32]
	call	__CIsqrt
	fmul	QWORD PTR __real@40bc200000000000

; 391  : 		wISO = hISO / sqrt(2.0);
; 392  : 		for (int i = 0; i <= 6; ++i) {

	xor	ecx, ecx
	fdiv	QWORD PTR __real@400451eb851eb852
	fld	ST(0)
	fld	QWORD PTR tv276[esp+32]
	fdiv	ST(1), ST(0)
	fld1
	fld	QWORD PTR _h$[esp+32]
	fld	QWORD PTR _w$[esp+32]
	jmp	SHORT $LN6@getISOANum
$LN61@getISOANum:
	fxch	ST(4)
	fxch	ST(5)
$LN6@getISOANum:

; 393  : 			if ((fabs(w - wISO) < 1 && fabs(h - hISO) < 1) || (fabs(w - hISO) < 1 && fabs(h - wISO) < 1)) {

	fld	ST(0)
	fsub	ST(0), ST(5)
	fabs
	fcomp	ST(3)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN1@getISOANum
	fld	ST(1)
	fsub	ST(0), ST(6)
	fabs
	fcomp	ST(3)
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN54@getISOANum
$LN1@getISOANum:
	fld	ST(0)
	fsubrp	ST(6), ST(0)
	fxch	ST(5)
	fabs
	fcomp	ST(2)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN3@getISOANum
	fld	ST(0)
	fsub	ST(0), ST(4)
	fabs
	fcomp	ST(2)
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN58@getISOANum
$LN3@getISOANum:

; 396  : 			}
; 397  : 			hISO = wISO;

	fld	ST(3)
	inc	ecx
	cmp	ecx, 6

; 398  : 			wISO /= sqrt(2.0);

	fxch	ST(4)
	fdiv	ST(0), ST(3)
	jle	SHORT $LN61@getISOANum
	fstp	ST(0)

; 399  : 		}
; 400  : 	}
; 401  : 	delete iso;

	push	esi
	fstp	ST(1)
	fstp	ST(2)
	fstp	ST(2)
	fstp	ST(0)
	fstp	ST(0)
	call	??3@YAXPAX@Z				; operator delete

; 402  : 	//Unknow ISO Name Size
; 403  : 	return "unknown";

	mov	eax, OFFSET ??_C@_07CIFAGBMG@unknown?$AA@
	add	esp, 4

; 404  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN54@getISOANum:

; 393  : 			if ((fabs(w - wISO) < 1 && fabs(h - hISO) < 1) || (fabs(w - hISO) < 1 && fabs(h - wISO) < 1)) {

	fstp	ST(4)
	fstp	ST(1)
	fstp	ST(3)
	fstp	ST(1)
	fstp	ST(1)
	jmp	SHORT $LN63@getISOANum
$LN58@getISOANum:
	fstp	ST(3)
	fstp	ST(0)
	fstp	ST(2)
	fstp	ST(0)
$LN63@getISOANum:

; 394  : 				sprintf(iso,"A%d",i);

	push	ecx
	fstp	ST(0)
	push	OFFSET ??_C@_03MCAEDFBD@A?$CFd?$AA@
	push	esi
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH

; 395  : 				return iso;

	mov	eax, esi

; 404  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?getISOANum@PDFPageInterop@@QAEPADXZ ENDP		; PDFPageInterop::getISOANum
_TEXT	ENDS
PUBLIC	?getPageWidth@PDFPageInterop@@QAENXZ		; PDFPageInterop::getPageWidth
; Function compile flags: /Ogtpy
;	COMDAT ?getPageWidth@PDFPageInterop@@QAENXZ
_TEXT	SEGMENT
?getPageWidth@PDFPageInterop@@QAENXZ PROC		; PDFPageInterop::getPageWidth, COMDAT
; _this$ = ecx

; 371  : 	AFPDFDoc *doc = (AFPDFDoc *)_pdfDoc;
; 372  : 	double w = doc->getDoc()->getPageCropWidth(_page);

	mov	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR [eax+332]
	mov	eax, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [edx+ecx*4-4]
	mov	eax, DWORD PTR [eax+8]
	fld	QWORD PTR [eax+48]
	fsub	QWORD PTR [eax+32]

; 373  :   
; 374  : 	return 254*w/72;

	fmul	QWORD PTR __real@406fc00000000000
	fdiv	QWORD PTR __real@4052000000000000

; 375  : }

	ret	0
?getPageWidth@PDFPageInterop@@QAENXZ ENDP		; PDFPageInterop::getPageWidth
_TEXT	ENDS
PUBLIC	?CvtUserToDevDpi@PDFPageInterop@@AAEXNHHPAH0@Z	; PDFPageInterop::CvtUserToDevDpi
; Function compile flags: /Ogtpy
;	COMDAT ?CvtUserToDevDpi@PDFPageInterop@@AAEXNHHPAH0@Z
_TEXT	SEGMENT
_lctm$85431 = -48					; size = 48
_dpi$ = 8						; size = 8
_xu$ = 16						; size = 4
_yu$ = 20						; size = 4
?CvtUserToDevDpi@PDFPageInterop@@AAEXNHHPAH0@Z PROC	; PDFPageInterop::CvtUserToDevDpi, COMDAT
; _this$ = esi
; _xd$ = ebx
; _yd$ = edi

; 269  : {

	push	ebp
	mov	ebp, esp
	and	esp, -64				; ffffffc0H

; 270  : 	if(_ctmdpi!=dpi){

	fld	QWORD PTR _dpi$[ebp]
	sub	esp, 64					; 00000040H
	fcom	QWORD PTR [esi+88]
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN6@CvtUserToD

; 271  : 		double lctm[6];
; 272  : 		((Page *)_pdfPage)->getDefaultCTM(lctm, dpi, dpi, 0,  gFalse, gFalse);

	mov	ecx, DWORD PTR [esi+8]
	push	0
	push	0
	push	0
	sub	esp, 16					; 00000010H
	fst	QWORD PTR [esp+8]
	lea	eax, DWORD PTR _lctm$85431[esp+92]
	fstp	QWORD PTR [esp]
	push	eax
	call	?getDefaultCTM@Page@@QAEXPANNNHHH@Z	; Page::getDefaultCTM

; 273  : 		*xd = (int)(lctm[0] * xu + lctm[2] * yu + lctm[4] + 0.5);

	fild	DWORD PTR _yu$[ebp]
	fild	DWORD PTR _xu$[ebp]
	fld	QWORD PTR _lctm$85431[esp+64]
	fmul	ST(0), ST(1)
	fld	ST(2)
	fmul	QWORD PTR _lctm$85431[esp+80]
	faddp	ST(1), ST(0)
	fadd	QWORD PTR _lctm$85431[esp+96]
	fld	QWORD PTR __real@3fe0000000000000
	fadd	ST(1), ST(0)
	fxch	ST(1)
	call	__ftol2_sse

; 274  : 		*yd = (int)(lctm[1] * xu + lctm[3] * yu + lctm[5] + 0.5);

	fxch	ST(1)
	fmul	QWORD PTR _lctm$85431[esp+72]
	mov	DWORD PTR [ebx], eax
	fxch	ST(2)
	fmul	QWORD PTR _lctm$85431[esp+88]
	faddp	ST(2), ST(0)
	fxch	ST(1)
	fadd	QWORD PTR _lctm$85431[esp+104]

; 277  : 		*yd = (int)(ctm[1] * xu + ctm[3] * yu + ctm[5] + 0.5);

	faddp	ST(1), ST(0)
	call	__ftol2_sse
	mov	DWORD PTR [edi], eax

; 278  : 	}
; 279  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN6@CvtUserToD:

; 270  : 	if(_ctmdpi!=dpi){

	fstp	ST(0)

; 275  : 	}else{
; 276  : 		*xd = (int)(ctm[0] * xu + ctm[2] * yu + ctm[4] + 0.5);

	fild	DWORD PTR _xu$[ebp]
	fild	DWORD PTR _yu$[ebp]
	fld	QWORD PTR [esi+40]
	fmul	ST(0), ST(2)
	fld	QWORD PTR [esi+56]
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fadd	QWORD PTR [esi+72]
	fld	QWORD PTR __real@3fe0000000000000
	fadd	ST(1), ST(0)
	fxch	ST(1)
	call	__ftol2_sse
	mov	DWORD PTR [ebx], eax

; 277  : 		*yd = (int)(ctm[1] * xu + ctm[3] * yu + ctm[5] + 0.5);

	fld	QWORD PTR [esi+48]
	fmulp	ST(3), ST(0)
	fld	QWORD PTR [esi+64]
	fmulp	ST(2), ST(0)
	fxch	ST(2)
	faddp	ST(1), ST(0)
	fadd	QWORD PTR [esi+80]
	faddp	ST(1), ST(0)
	call	__ftol2_sse
	mov	DWORD PTR [edi], eax

; 278  : 	}
; 279  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?CvtUserToDevDpi@PDFPageInterop@@AAEXNHHPAH0@Z ENDP	; PDFPageInterop::CvtUserToDevDpi
; Function compile flags: /Ogtpy
;	COMDAT ??_GTextPage@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GTextPage@@QAEPAXI@Z PROC				; TextPage::`scalar deleting destructor', COMDAT
; _this$ = esi
	mov	ecx, esi
	call	??1TextPage@@QAE@XZ			; TextPage::~TextPage
	test	BYTE PTR ___flags$[esp-4], 1
	je	SHORT $LN4@scalar@12
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@12:
	mov	eax, esi
	ret	4
??_GTextPage@@QAEPAXI@Z ENDP				; TextPage::`scalar deleting destructor'
PUBLIC	?getLinks@PDFPageInterop@@QAEPAVPageLinksInterop@@XZ ; PDFPageInterop::getLinks
; Function compile flags: /Ogtpy
;	COMDAT ?getLinks@PDFPageInterop@@QAEPAVPageLinksInterop@@XZ
_TEXT	SEGMENT
?getLinks@PDFPageInterop@@QAEPAVPageLinksInterop@@XZ PROC ; PDFPageInterop::getLinks, COMDAT
; _this$ = eax

; 104  : 	AFPDFDocInterop *doc = (AFPDFDocInterop *)_pdfDoc;
; 105  : 	if(_page>=0 && _page<doc->GetPageCount()){

	mov	edx, DWORD PTR [eax+32]
	mov	ecx, DWORD PTR [eax+4]
	test	edx, edx
	jl	SHORT $LN1@getLinks
	mov	eax, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [eax+332]
	test	eax, eax
	je	SHORT $LN6@getLinks
	cmp	DWORD PTR [eax+36], 0
	je	SHORT $LN6@getLinks
	mov	eax, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [eax+12]
	jmp	SHORT $LN8@getLinks
$LN6@getLinks:
	xor	eax, eax
$LN8@getLinks:
	cmp	edx, eax
	jge	SHORT $LN1@getLinks

; 106  : 		PageLinksInterop *pl = doc->getPageLinksInterop(_page);

	push	edx
	call	?getPageLinksInterop@AFPDFDocInterop@@QAEPAVPageLinksInterop@@J@Z ; AFPDFDocInterop::getPageLinksInterop

; 110  : }

	ret	0
$LN1@getLinks:

; 107  : 		return pl;
; 108  : 	}
; 109  : 	return 0;

	xor	eax, eax

; 110  : }

	ret	0
?getLinks@PDFPageInterop@@QAEPAVPageLinksInterop@@XZ ENDP ; PDFPageInterop::getLinks
PUBLIC	?getText@PDFPageInterop@@QAEPA_WXZ		; PDFPageInterop::getText
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?getText@PDFPageInterop@@QAEPA_WXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?getText@PDFPageInterop@@QAEPA_WXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?getText@PDFPageInterop@@QAEPA_WXZ$1
__ehfuncinfo$?getText@PDFPageInterop@@QAEPA_WXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?getText@PDFPageInterop@@QAEPA_WXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?getText@PDFPageInterop@@QAEPA_WXZ
_TEXT	SEGMENT
$T190790 = -28						; size = 4
_exitcode$190824 = -24					; size = 4
_exitcode$190817 = -24					; size = 4
$T190791 = -24						; size = 4
$T190787 = -24						; size = 4
_isUnicode$85502 = -20					; size = 4
_doc$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?getText@PDFPageInterop@@QAEPA_WXZ PROC			; PDFPageInterop::getText, COMDAT
; _this$ = ecx

; 308  : wchar_t *PDFPageInterop::getText(){

	push	-1
	push	__ehhandler$?getText@PDFPageInterop@@QAEPA_WXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+48]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[esp+48], ecx

; 309  : 	AFPDFDoc *doc = (AFPDFDoc *)_pdfDoc;

	mov	ebp, DWORD PTR [ecx+4]

; 310  : 	GString *s1 = new GString();

	push	8
	mov	DWORD PTR _doc$[esp+52], ebp
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T190787[esp+48], eax
	xor	esi, esi
	mov	DWORD PTR __$EHRec$[esp+56], esi
	cmp	eax, esi
	je	SHORT $LN14@getText
	mov	ecx, eax
	call	??0GString@@QAE@XZ			; GString::GString
	mov	edi, eax
	jmp	SHORT $LN15@getText
$LN14@getText:
	xor	edi, edi
$LN15@getText:
	mov	DWORD PTR __$EHRec$[esp+56], -1

; 311  : 	//CString *s2 = new CString();
; 312  : 
; 313  : 	globalParams->setTextEncoding("UTF-8");

	mov	ecx, DWORD PTR ?globalParams@@3PAVGlobalParams@@A ; globalParams
	push	OFFSET ??_C@_05EGJIMALK@UTF?98?$AA@
	call	?setTextEncoding@GlobalParams@@QAEXPAD@Z ; GlobalParams::setTextEncoding

; 314  : 	UnicodeMap *map=globalParams->getTextEncoding();

	mov	ecx, DWORD PTR ?globalParams@@3PAVGlobalParams@@A ; globalParams
	call	?getTextEncoding@GlobalParams@@QAEPAVUnicodeMap@@XZ ; GlobalParams::getTextEncoding

; 315  : 	
; 316  : 	
; 317  : 	TextOutputDev *txt= new TextOutputDev((TextOutputFunc)&WriteToGString,(void *)s1,gTrue,gFalse);

	push	136					; 00000088H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T190791[esp+48], eax
	mov	DWORD PTR __$EHRec$[esp+56], 1
	cmp	eax, esi
	je	SHORT $LN16@getText
	push	esi
	push	1
	push	edi
	push	OFFSET ?WriteToGString@@YAXPAXPADH@Z	; WriteToGString
	mov	ecx, eax
	call	??0TextOutputDev@@QAE@P6AXPAXPADH@Z0HH@Z ; TextOutputDev::TextOutputDev
	mov	ebx, eax
	mov	DWORD PTR $T190790[esp+48], ebx
	jmp	SHORT $LN17@getText
$LN16@getText:
	mov	DWORD PTR $T190790[esp+48], esi
	mov	ebx, esi
$LN17@getText:
	mov	DWORD PTR __$EHRec$[esp+56], -1

; 318  : 	if(doc->IsBusy())

	mov	eax, DWORD PTR [ebp+240]
	cmp	eax, esi
	je	SHORT $LN32@getText
	mov	ebp, DWORD PTR __imp__GetExitCodeThread@8
	lea	ecx, DWORD PTR _exitcode$190817[esp+48]
	push	ecx
	push	eax
	mov	DWORD PTR _exitcode$190817[esp+56], esi
	call	ebp
	cmp	DWORD PTR _exitcode$190817[esp+48], 259	; 00000103H
	jne	SHORT $LN71@getText
$LL10@getText:

; 319  : 		while(doc->IsBusy()) 

	mov	edx, DWORD PTR _doc$[esp+48]
	mov	eax, DWORD PTR [edx+240]
	cmp	eax, esi
	je	SHORT $LN71@getText
	lea	ecx, DWORD PTR _exitcode$190824[esp+48]
	push	ecx
	push	eax
	mov	DWORD PTR _exitcode$190824[esp+56], esi
	call	ebp
	cmp	DWORD PTR _exitcode$190824[esp+48], 259	; 00000103H
	jne	SHORT $LN71@getText

; 320  : 			Sleep(50);

	push	50					; 00000032H
	call	DWORD PTR __imp__Sleep@4
	jmp	SHORT $LL10@getText
$LN71@getText:
	mov	ebp, DWORD PTR _doc$[esp+48]

; 319  : 		while(doc->IsBusy()) 

$LN32@getText:

; 321  : 	doc->getDoc()->displayPage(txt,_page,72,72,0,gFalse,gTrue,gFalse);

	fld	QWORD PTR __real@4052000000000000
	mov	edx, DWORD PTR _this$[esp+48]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR [ebp+332]
	push	esi
	push	esi
	push	esi
	push	1
	push	esi
	push	esi
	sub	esp, 16					; 00000010H
	fst	QWORD PTR [esp+8]
	fstp	QWORD PTR [esp]
	push	eax
	push	ebx
	call	?displayPage@PDFDoc@@QAEXPAVOutputDev@@HNNHHHHP6AHPAX@Z1@Z ; PDFDoc::displayPage

; 322  : 	
; 323  : 	int size = s1->getLength();

	mov	ebp, DWORD PTR [edi]

; 324  : 	if(size>0){

	cmp	ebp, esi
	jle	$LN8@getText

; 325  : 		wchar_t *ret = NULL;
; 326  : 			
; 327  : 		GBool isUnicode=gFalse;
; 328  : 		Unicode u;
; 329  : 		int i;
; 330  : 		if ((s1->getChar(0) & 0xff) == 0xfe && (s1->getChar(1) & 0xff) == 0xff) {

	mov	eax, DWORD PTR [edi+4]
	cmp	BYTE PTR [eax], 254			; 000000feH
	jne	SHORT $LN7@getText
	cmp	BYTE PTR [eax+1], 255			; 000000ffH
	jne	SHORT $LN7@getText

; 331  : 			isUnicode = gTrue;

	mov	DWORD PTR _isUnicode$85502[esp+48], 1

; 332  : 			i = 2;

	mov	esi, 2

; 333  : 		} else {

	jmp	SHORT $LN6@getText
$LN7@getText:

; 334  : 			isUnicode = gFalse;

	mov	DWORD PTR _isUnicode$85502[esp+48], esi
$LN6@getText:

; 335  : 			i = 0;
; 336  : 		}
; 337  : 		//Unicode Support
; 338  : 		//if(!isUnicode)
; 339  : 		ret = UTF8translate(s1->getCString());

	push	eax
	call	?UTF8translate@@YAPA_WQAD@Z		; UTF8translate
	mov	ebx, eax
	add	esp, 4

; 340  : 		if(ret==NULL)

	test	ebx, ebx
	jne	$LN20@getText

; 341  : 		{
; 342  : 			ret =new wchar_t[size+1];

	xor	ecx, ecx
	lea	eax, DWORD PTR [ebp+1]
	mov	edx, 2
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4

; 343  : 			int j=0;

	xor	edx, edx

; 344  : 
; 345  : 			while (i < s1->getLength()) {

	cmp	esi, DWORD PTR [edi]
	mov	ebx, eax
	jge	SHORT $LN3@getText
$LL4@getText:

; 346  : 				  if (isUnicode) {

	cmp	DWORD PTR _isUnicode$85502[esp+48], 0

; 347  : 						u = ((s1->getChar(i) & 0xff) << 8) | (s1->getChar(i+1) & 0xff);

	mov	eax, DWORD PTR [edi+4]
	je	SHORT $LN2@getText
	lea	ecx, DWORD PTR [eax+esi]
	movsx	eax, BYTE PTR [ecx+1]
	movsx	ecx, BYTE PTR [ecx]
	and	ecx, 255				; 000000ffH
	and	eax, 255				; 000000ffH
	shl	ecx, 8
	or	eax, ecx

; 348  : 						i += 2;

	add	esi, 2

; 349  : 				  } else {

	jmp	SHORT $LN1@getText
$LN2@getText:

; 350  : 						u = s1->getChar(i) & 0xff;

	movsx	eax, BYTE PTR [eax+esi]
	and	eax, 255				; 000000ffH

; 351  : 						++i;

	inc	esi
$LN1@getText:

; 352  : 				  }
; 353  : 				  ret[j] = u;

	mov	WORD PTR [ebx+edx*2], ax

; 354  : 				  j++;

	inc	edx
	cmp	esi, DWORD PTR [edi]
	jl	SHORT $LL4@getText
$LN3@getText:

; 355  : 			}
; 356  : 
; 357  : 			ret[j]='\0';

	xor	ecx, ecx
	mov	WORD PTR [ebx+edx*2], cx

; 358  : 			
; 359  : 			delete s1;

	mov	ecx, edi
	call	??1GString@@QAE@XZ			; GString::~GString
	push	edi
	call	??3@YAXPAX@Z				; operator delete

; 360  : 			delete txt;	

	mov	ecx, DWORD PTR $T190790[esp+52]
	add	esp, 4
	test	ecx, ecx
	je	SHORT $LN20@getText
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx]
	push	1
	call	eax
$LN20@getText:

; 361  : 		}
; 362  : 
; 363  : 		return ret;	

	mov	eax, ebx

; 368  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 28					; 0000001cH
	ret	0
$LN8@getText:

; 364  : 	}
; 365  : 	delete s1;

	mov	ecx, edi
	call	??1GString@@QAE@XZ			; GString::~GString
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 366  : 	delete txt;

	cmp	ebx, esi
	je	SHORT $LN24@getText
	mov	edx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [edx]
	push	1
	mov	ecx, ebx
	call	eax
$LN24@getText:

; 367  : 	return EmptyChar;

	mov	eax, OFFSET _EmptyChar

; 368  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 28					; 0000001cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?getText@PDFPageInterop@@QAEPA_WXZ$0:
	mov	eax, DWORD PTR $T190787[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?getText@PDFPageInterop@@QAEPA_WXZ$1:
	mov	eax, DWORD PTR $T190791[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?getText@PDFPageInterop@@QAEPA_WXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-32]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?getText@PDFPageInterop@@QAEPA_WXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?getText@PDFPageInterop@@QAEPA_WXZ ENDP			; PDFPageInterop::getText
PUBLIC	?getTextStream@PDFPageInterop@@QAEXPAX@Z	; PDFPageInterop::getTextStream
;	COMDAT xdata$x
; File c:\projects\pdflibnet\libafpdflib\afpdfdoc.h
xdata$x	SEGMENT
__unwindtable$?getTextStream@PDFPageInterop@@QAEXPAX@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?getTextStream@PDFPageInterop@@QAEXPAX@Z$0
__ehfuncinfo$?getTextStream@PDFPageInterop@@QAEXPAX@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?getTextStream@PDFPageInterop@@QAEXPAX@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\projects\pdflibnet\libafpdflib\pdfpageinterop.cpp
xdata$x	ENDS
;	COMDAT ?getTextStream@PDFPageInterop@@QAEXPAX@Z
_TEXT	SEGMENT
$T190892 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_stream$ = 8						; size = 4
?getTextStream@PDFPageInterop@@QAEXPAX@Z PROC		; PDFPageInterop::getTextStream, COMDAT
; _this$ = ecx

; 298  : void PDFPageInterop::getTextStream(void *stream){

	push	-1
	push	__ehhandler$?getTextStream@PDFPageInterop@@QAEXPAX@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx

; 299  : 	TextOutputFunc fn=(TextOutputFunc)&::OutputToDelegate;
; 300  : 	AFPDFDoc *doc = (AFPDFDoc *)_pdfDoc;

	mov	ebx, DWORD PTR [edi+4]

; 301  : 	
; 302  : 	TextOutputDev *txt= new TextOutputDev((TextOutputFunc)fn,(void *)stream,gTrue,gFalse);

	push	136					; 00000088H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T190892[esp+32], eax
	mov	DWORD PTR __$EHRec$[esp+40], 0
	test	eax, eax
	je	SHORT $LN3@getTextStr
	mov	ecx, DWORD PTR _stream$[esp+28]
	push	0
	push	1
	push	ecx
	push	OFFSET ?OutputToDelegate@@YAXPAXPADH@Z	; OutputToDelegate
	mov	ecx, eax
	call	??0TextOutputDev@@QAE@P6AXPAXPADH@Z0HH@Z ; TextOutputDev::TextOutputDev
	mov	esi, eax
	jmp	SHORT $LN4@getTextStr
$LN3@getTextStr:
	xor	esi, esi
$LN4@getTextStr:

; 303  : 	doc->getDoc()->displayPage(txt,_page,72,72,0,gFalse,gFalse,gFalse);

	push	0
	push	0
	push	0
	push	0
	push	0
	mov	DWORD PTR __$EHRec$[esp+60], -1
	fld	QWORD PTR __real@4052000000000000
	mov	edx, DWORD PTR [edi+32]
	mov	ecx, DWORD PTR [ebx+332]
	push	0
	sub	esp, 16					; 00000010H
	fst	QWORD PTR [esp+8]
	fstp	QWORD PTR [esp]
	push	edx
	push	esi
	call	?displayPage@PDFDoc@@QAEXPAVOutputDev@@HNNHHHHP6AHPAX@Z1@Z ; PDFDoc::displayPage

; 304  : 	delete txt;

	test	esi, esi
	je	SHORT $LN5@getTextStr
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	1
	mov	ecx, esi
	call	edx
$LN5@getTextStr:

; 305  : 
; 306  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?getTextStream@PDFPageInterop@@QAEXPAX@Z$0:
	mov	eax, DWORD PTR $T190892[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?getTextStream@PDFPageInterop@@QAEXPAX@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-16]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?getTextStream@PDFPageInterop@@QAEXPAX@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?getTextStream@PDFPageInterop@@QAEXPAX@Z ENDP		; PDFPageInterop::getTextStream
PUBLIC	?takeText@PDFPageInterop@@AAEXXZ		; PDFPageInterop::takeText
;	COMDAT xdata$x
; File c:\projects\pdflibnet\libafpdflib\afpdfdoc.h
xdata$x	SEGMENT
__unwindtable$?takeText@PDFPageInterop@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?takeText@PDFPageInterop@@AAEXXZ$0
__ehfuncinfo$?takeText@PDFPageInterop@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?takeText@PDFPageInterop@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\projects\pdflibnet\libafpdflib\pdfpageinterop.cpp
xdata$x	ENDS
;	COMDAT ?takeText@PDFPageInterop@@AAEXXZ
_TEXT	SEGMENT
tv311 = -20						; size = 4
_exitcode$190937 = -20					; size = 4
_exitcode$190930 = -20					; size = 4
tv302 = -16						; size = 4
$T190915 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?takeText@PDFPageInterop@@AAEXXZ PROC			; PDFPageInterop::takeText, COMDAT
; _this$ = esi

; 252  : {

	push	-1
	push	__ehhandler$?takeText@PDFPageInterop@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	ebx
	push	ebp
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, eax

; 253  : 	AFPDFDoc *doc = (AFPDFDoc *)_pdfDoc;
; 254  : 	//Extract text
; 255  : 	if(_text==0 || doc->GetRenderDPI()!=dpi){

	mov	ecx, DWORD PTR [esi+16]
	mov	ebx, DWORD PTR [esi+4]
	xor	ebp, ebp
	cmp	ecx, ebp
	je	SHORT $LN4@takeText
	fld	QWORD PTR [ebx+536]
	fstp	DWORD PTR tv311[esp+36]
	fld	DWORD PTR tv311[esp+36]
	fcomp	QWORD PTR [esi+24]
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	$LN11@takeText

; 256  : 		if(_text)	delete _text;

	cmp	ecx, ebp
	je	SHORT $LN4@takeText
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@takeText:

; 257  : 		TextOutputDev *txt = new TextOutputDev(NULL,gTrue,gFalse,gFalse);

	push	136					; 00000088H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T190915[esp+36], eax
	mov	DWORD PTR __$EHRec$[esp+44], ebp
	cmp	eax, ebp
	je	SHORT $LN9@takeText
	push	ebp
	push	ebp
	push	1
	push	ebp
	mov	ecx, eax
	call	??0TextOutputDev@@QAE@PADHHH@Z		; TextOutputDev::TextOutputDev
	mov	edi, eax
	jmp	SHORT $LN10@takeText
$LN9@takeText:
	xor	edi, edi
$LN10@takeText:
	mov	DWORD PTR __$EHRec$[esp+44], -1

; 258  : 		if(doc->IsBusy())

	mov	eax, DWORD PTR [ebx+240]
	cmp	eax, ebp
	je	SHORT $LN20@takeText
	lea	ecx, DWORD PTR _exitcode$190930[esp+36]
	push	ecx
	mov	DWORD PTR _exitcode$190930[esp+40], ebp
	mov	ebp, DWORD PTR __imp__GetExitCodeThread@8
	push	eax
	call	ebp
	cmp	DWORD PTR _exitcode$190930[esp+36], 259	; 00000103H
	jne	SHORT $LN20@takeText
$LL2@takeText:

; 259  : 			while(doc->IsBusy()) Sleep(50);

	mov	eax, DWORD PTR [ebx+240]
	test	eax, eax
	je	SHORT $LN20@takeText
	lea	edx, DWORD PTR _exitcode$190937[esp+36]
	push	edx
	push	eax
	mov	DWORD PTR _exitcode$190937[esp+44], 0
	call	ebp
	cmp	DWORD PTR _exitcode$190937[esp+36], 259	; 00000103H
	jne	SHORT $LN20@takeText
	push	50					; 00000032H
	call	DWORD PTR __imp__Sleep@4
	jmp	SHORT $LL2@takeText
$LN20@takeText:

; 260  : 		dpi = doc->GetRenderDPI();

	fld	QWORD PTR [ebx+536]

; 261  : 		doc->getDoc()->displayPage(txt,_page,dpi,dpi,0,gFalse,gFalse,gFalse);

	mov	eax, DWORD PTR [esi+32]
	push	0
	fstp	DWORD PTR tv302[esp+40]
	fld	DWORD PTR tv302[esp+40]
	push	0
	push	0
	fst	QWORD PTR [esi+24]
	mov	ecx, DWORD PTR [ebx+332]
	push	0
	push	0
	push	0
	sub	esp, 16					; 00000010H
	fst	QWORD PTR [esp+8]
	fstp	QWORD PTR [esp]
	push	eax
	push	edi
	call	?displayPage@PDFDoc@@QAEXPAVOutputDev@@HNNHHHHP6AHPAX@Z1@Z ; PDFDoc::displayPage

; 262  : 		((Page *)_pdfPage)->getDefaultCTM(ctm, dpi, dpi, 0,  gFalse, gFalse);

	fld	QWORD PTR [esi+24]
	push	0
	push	0
	push	0
	sub	esp, 16					; 00000010H
	fstp	QWORD PTR [esp+8]
	lea	ecx, DWORD PTR [esi+40]
	fld	QWORD PTR [esi+24]
	fstp	QWORD PTR [esp]
	push	ecx
	mov	ecx, DWORD PTR [esi+8]
	call	?getDefaultCTM@Page@@QAEXPANNNHHH@Z	; Page::getDefaultCTM

; 263  : 		_ctmdpi=dpi;

	fld	QWORD PTR [esi+24]

; 264  : 		_text = txt->takeText();

	mov	ecx, edi
	fstp	QWORD PTR [esi+88]
	call	?takeText@TextOutputDev@@QAEPAVTextPage@@XZ ; TextOutputDev::takeText
	mov	DWORD PTR [esi+16], eax

; 265  : 		delete txt;

	test	edi, edi
	je	SHORT $LN11@takeText
	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx]
	push	1
	mov	ecx, edi
	call	eax
$LN11@takeText:

; 266  : 	}
; 267  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?takeText@PDFPageInterop@@AAEXXZ$0:
	mov	eax, DWORD PTR $T190915[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?takeText@PDFPageInterop@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-20]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?takeText@PDFPageInterop@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?takeText@PDFPageInterop@@AAEXXZ ENDP			; PDFPageInterop::takeText
PUBLIC	?extractImages@PDFPageInterop@@QAEXXZ		; PDFPageInterop::extractImages
;	COMDAT xdata$x
; File c:\projects\pdflibnet\libafpdflib\afpdfdoc.h
xdata$x	SEGMENT
__unwindtable$?extractImages@PDFPageInterop@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?extractImages@PDFPageInterop@@QAEXXZ$0
__ehfuncinfo$?extractImages@PDFPageInterop@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?extractImages@PDFPageInterop@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\projects\pdflibnet\libafpdflib\pdfpageinterop.cpp
xdata$x	ENDS
;	COMDAT ?extractImages@PDFPageInterop@@QAEXXZ
_TEXT	SEGMENT
$T190963 = -20						; size = 4
_exitcode$190979 = -16					; size = 4
_exitcode$190972 = -16					; size = 4
$T190964 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?extractImages@PDFPageInterop@@QAEXXZ PROC		; PDFPageInterop::extractImages, COMDAT
; _this$ = ecx

; 212  : {

	push	-1
	push	__ehhandler$?extractImages@PDFPageInterop@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, eax
	mov	ebp, ecx

; 213  : 	if(_images==0)

	xor	ebx, ebx
	cmp	DWORD PTR [ebp], ebx
	jne	$LN4@extractIma

; 214  : 	{
; 215  : 		AFPDFDoc *doc = (AFPDFDoc *)_pdfDoc;

	mov	esi, DWORD PTR [ebp+4]

; 216  : 		_images =(void *)new ImagesMemoryOutputDev();

	push	128					; 00000080H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T190964[esp+40], eax
	mov	DWORD PTR __$EHRec$[esp+48], ebx
	cmp	eax, ebx
	je	SHORT $LN7@extractIma
	push	eax
	call	??0ImagesMemoryOutputDev@@QAE@XZ	; ImagesMemoryOutputDev::ImagesMemoryOutputDev
	mov	DWORD PTR $T190963[esp+40], eax
	jmp	SHORT $LN8@extractIma
$LN7@extractIma:
	mov	DWORD PTR $T190963[esp+40], ebx
$LN8@extractIma:
	mov	eax, DWORD PTR $T190963[esp+40]
	mov	DWORD PTR __$EHRec$[esp+48], -1
	mov	DWORD PTR [ebp], eax

; 217  : 		ImagesMemoryOutputDev *img=(ImagesMemoryOutputDev *)_images;
; 218  : 		if(doc->IsBusy())

	mov	eax, DWORD PTR [esi+240]
	cmp	eax, ebx
	je	SHORT $LN14@extractIma
	mov	edi, DWORD PTR __imp__GetExitCodeThread@8
	lea	ecx, DWORD PTR _exitcode$190972[esp+40]
	push	ecx
	push	eax
	mov	DWORD PTR _exitcode$190972[esp+48], ebx
	call	edi
	cmp	DWORD PTR _exitcode$190972[esp+40], 259	; 00000103H
	jne	SHORT $LN14@extractIma
$LL2@extractIma:

; 219  : 			while(doc->IsBusy()) Sleep(50);

	mov	eax, DWORD PTR [esi+240]
	cmp	eax, ebx
	je	SHORT $LN14@extractIma
	lea	edx, DWORD PTR _exitcode$190979[esp+40]
	push	edx
	push	eax
	mov	DWORD PTR _exitcode$190979[esp+48], ebx
	call	edi
	cmp	DWORD PTR _exitcode$190979[esp+40], 259	; 00000103H
	jne	SHORT $LN14@extractIma
	push	50					; 00000032H
	call	DWORD PTR __imp__Sleep@4
	jmp	SHORT $LL2@extractIma
$LN14@extractIma:

; 220  : 		doc->getDoc()->displayPage(img,this->_page,72,72,0,gTrue,gFalse,gFalse,0,0);

	fld	QWORD PTR __real@4052000000000000
	mov	eax, DWORD PTR [ebp+32]
	mov	ecx, DWORD PTR $T190963[esp+40]
	push	ebx
	push	ebx
	push	ebx
	push	ebx
	push	1
	push	ebx
	sub	esp, 16					; 00000010H
	fst	QWORD PTR [esp+8]
	fstp	QWORD PTR [esp]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR [esi+332]
	call	?displayPage@PDFDoc@@QAEXPAVOutputDev@@HNNHHHHP6AHPAX@Z1@Z ; PDFDoc::displayPage
$LN4@extractIma:

; 221  : 	}
; 222  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?extractImages@PDFPageInterop@@QAEXXZ$0:
	mov	eax, DWORD PTR $T190964[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?extractImages@PDFPageInterop@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-24]
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?extractImages@PDFPageInterop@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?extractImages@PDFPageInterop@@QAEXXZ ENDP		; PDFPageInterop::extractImages
PUBLIC	?hasText@PDFPageInterop@@QAE_NHH@Z		; PDFPageInterop::hasText
; Function compile flags: /Ogtpy
;	COMDAT ?hasText@PDFPageInterop@@QAE_NHH@Z
_TEXT	SEGMENT
_y0$ = -8						; size = 4
_x0$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?hasText@PDFPageInterop@@QAE_NHH@Z PROC			; PDFPageInterop::hasText, COMDAT
; _this$ = ecx

; 197  : {

	push	ebp
	mov	ebp, esp
	and	esp, -64				; ffffffc0H
	sub	esp, 56					; 00000038H
	push	esi
	push	edi
	mov	esi, ecx

; 198  : 	AFPDFDoc *doc = (AFPDFDoc *)_pdfDoc;
; 199  : 	int x0, x1,y0,y1;
; 200  : 	takeText();

	call	?takeText@PDFPageInterop@@AAEXXZ	; PDFPageInterop::takeText

; 201  : 	TextPage *txt =(TextPage *)_text;
; 202  : 	CvtUserToDev(x,y,&x0,&y0);

	fild	DWORD PTR _x$[ebp]
	fild	DWORD PTR _y$[ebp]
	mov	edi, DWORD PTR [esi+16]
	fld	QWORD PTR [esi+56]
	fmul	ST(0), ST(1)
	fld	QWORD PTR [esi+40]
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fadd	QWORD PTR [esi+72]
	fld	QWORD PTR __real@3fe0000000000000
	fadd	ST(1), ST(0)
	fxch	ST(1)
	call	__ftol2_sse
	fld	QWORD PTR [esi+64]
	fmulp	ST(2), ST(0)
	mov	DWORD PTR _x0$[esp+64], eax
	fld	QWORD PTR [esi+48]
	fmulp	ST(3), ST(0)
	fxch	ST(1)
	faddp	ST(2), ST(0)
	fxch	ST(1)
	fadd	QWORD PTR [esi+80]
	faddp	ST(1), ST(0)
	call	__ftol2_sse
	mov	DWORD PTR _y0$[esp+64], eax

; 203  : 	
; 204  : 	if(txt){

	test	edi, edi
	je	SHORT $LN1@hasText

; 205  : 		if(txt->hasText(x0,y0))

	fild	DWORD PTR _y0$[esp+64]
	sub	esp, 16					; 00000010H
	mov	ecx, edi
	fstp	QWORD PTR [esp+8]
	fild	DWORD PTR _x0$[esp+80]
	fstp	QWORD PTR [esp]
	call	?hasText@TextPage@@QAEHNN@Z		; TextPage::hasText
	test	eax, eax
	je	SHORT $LN1@hasText

; 206  : 			return true;

	mov	al, 1

; 207  : 	}
; 208  : 	return false;
; 209  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
$LN1@hasText:
	pop	edi
	xor	al, al
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?hasText@PDFPageInterop@@QAE_NHH@Z ENDP			; PDFPageInterop::hasText
_TEXT	ENDS
PUBLIC	?extractText@PDFPageInterop@@QAEPA_WHHHH@Z	; PDFPageInterop::extractText
; Function compile flags: /Ogtpy
;	COMDAT ?extractText@PDFPageInterop@@QAEPA_WHHHH@Z
_TEXT	SEGMENT
_isUnicode$85299 = -20					; size = 4
_y1$ = -20						; size = 4
_x1$ = -16						; size = 4
_y0$ = -12						; size = 4
_x0$ = -8						; size = 4
_txt$ = -4						; size = 4
_xMin$ = 8						; size = 4
_yMin$ = 12						; size = 4
_xMax$ = 16						; size = 4
_yMax$ = 20						; size = 4
?extractText@PDFPageInterop@@QAEPA_WHHHH@Z PROC		; PDFPageInterop::extractText, COMDAT
; _this$ = ecx

; 142  : {

	push	ebp
	mov	ebp, esp
	and	esp, -64				; ffffffc0H
	sub	esp, 52					; 00000034H
	push	ebx
	push	esi
	push	edi
	mov	esi, ecx

; 143  : 	AFPDFDoc *doc = (AFPDFDoc *)_pdfDoc;
; 144  : 	int x0, x1,y0,y1;
; 145  : 	takeText();

	call	?takeText@PDFPageInterop@@AAEXXZ	; PDFPageInterop::takeText

; 146  : 	TextPage *txt =(TextPage *)_text;
; 147  : 	this->CvtUserToDev(xMin,yMin,&x0,&y0);

	fild	DWORD PTR _xMin$[ebp]
	fild	DWORD PTR _yMin$[ebp]
	mov	edi, DWORD PTR [esi+16]
	fld	QWORD PTR [esi+40]
	mov	DWORD PTR _txt$[esp+64], edi
	fmul	ST(0), ST(2)
	fld	ST(1)
	fmul	QWORD PTR [esi+56]
	faddp	ST(1), ST(0)
	fadd	QWORD PTR [esi+72]
	fld	QWORD PTR __real@3fe0000000000000
	fadd	ST(1), ST(0)
	fxch	ST(1)
	call	__ftol2_sse
	fxch	ST(1)
	fmul	QWORD PTR [esi+64]
	mov	DWORD PTR _x0$[esp+64], eax
	fxch	ST(2)
	fmul	QWORD PTR [esi+48]
	faddp	ST(2), ST(0)
	fxch	ST(1)
	fadd	QWORD PTR [esi+80]
	fadd	ST(0), ST(1)
	call	__ftol2_sse

; 148  : 	this->CvtUserToDev(xMax,yMax,&x1,&y1);

	fild	DWORD PTR _xMax$[ebp]
	fild	DWORD PTR _yMax$[ebp]
	mov	DWORD PTR _y0$[esp+64], eax
	fld	QWORD PTR [esi+40]
	fmul	ST(0), ST(2)
	fld	ST(1)
	fmul	QWORD PTR [esi+56]
	faddp	ST(1), ST(0)
	fadd	QWORD PTR [esi+72]
	fadd	ST(0), ST(3)
	call	__ftol2_sse
	fmul	QWORD PTR [esi+64]
	fxch	ST(1)
	mov	DWORD PTR _x1$[esp+64], eax
	fmul	QWORD PTR [esi+48]
	faddp	ST(1), ST(0)
	fadd	QWORD PTR [esi+80]
	faddp	ST(1), ST(0)
	call	__ftol2_sse
	mov	DWORD PTR _y1$[esp+64], eax

; 149  : 
; 150  : 	GString *s1 = txt->getText(x0,y0,x1,y1);

	fild	DWORD PTR _y1$[esp+64]
	sub	esp, 32					; 00000020H
	mov	ecx, edi
	fstp	QWORD PTR [esp+24]
	fild	DWORD PTR _x1$[esp+96]
	fstp	QWORD PTR [esp+16]
	fild	DWORD PTR _y0$[esp+96]
	fstp	QWORD PTR [esp+8]
	fild	DWORD PTR _x0$[esp+96]
	fstp	QWORD PTR [esp]
	call	?getText@TextPage@@QAEPAVGString@@NNNN@Z ; TextPage::getText
	mov	edi, eax

; 151  : 	GBool isUnicode=gFalse;
; 152  : 	
; 153  : 	if(s1 && s1->getLength()>0){

	xor	esi, esi
	cmp	edi, esi
	je	$LN53@extractTex
	mov	ebx, DWORD PTR [edi]
	cmp	ebx, esi
	jle	$LN14@extractTex

; 154  : 		int size=s1->getLength();
; 155  : 		wchar_t *ret = NULL;
; 156  : 			
; 157  : 		GBool isUnicode=gFalse;
; 158  : 		Unicode u;
; 159  : 		int i;
; 160  : 		if ((s1->getChar(0) & 0xff) == 0xfe && (s1->getChar(1) & 0xff) == 0xff) {

	mov	eax, DWORD PTR [edi+4]
	cmp	BYTE PTR [eax], 254			; 000000feH
	jne	SHORT $LN8@extractTex
	cmp	BYTE PTR [eax+1], 255			; 000000ffH
	jne	SHORT $LN8@extractTex

; 161  : 			isUnicode = gTrue;

	mov	DWORD PTR _isUnicode$85299[esp+64], 1

; 162  : 			i = 2;

	mov	esi, 2

; 163  : 		} else {

	jmp	SHORT $LN51@extractTex
$LN8@extractTex:

; 164  : 			isUnicode = gFalse;
; 165  : 			i = 0;
; 166  : 		}
; 167  : 		//Unicode Support
; 168  : 		if(!isUnicode)
; 169  : 			ret = UTF8translate(s1->getCString());

	push	eax
	mov	DWORD PTR _isUnicode$85299[esp+68], esi
	call	?UTF8translate@@YAPA_WQAD@Z		; UTF8translate
	add	esp, 4

; 170  : 		if(ret==NULL)

	test	eax, eax
	jne	$LN14@extractTex
$LN51@extractTex:

; 171  : 		{
; 172  : 			ret =new wchar_t[size+1];

	xor	ecx, ecx
	lea	eax, DWORD PTR [ebx+1]
	mov	edx, 2
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	ebx, eax
	add	esp, 4

; 173  : 			int j=0;

	xor	eax, eax

; 174  : 
; 175  : 			while (i < s1->getLength()) {

	cmp	esi, DWORD PTR [edi]
	jge	SHORT $LN3@extractTex
$LN4@extractTex:

; 176  : 				  if (isUnicode) {

	cmp	DWORD PTR _isUnicode$85299[esp+64], 0

; 177  : 						u = ((s1->getChar(i) & 0xff) << 8) | (s1->getChar(i+1) & 0xff);

	mov	ecx, DWORD PTR [edi+4]
	je	SHORT $LN2@extractTex
	lea	edx, DWORD PTR [ecx+esi]
	movsx	ecx, BYTE PTR [edx]
	movsx	edx, BYTE PTR [edx+1]
	and	ecx, 255				; 000000ffH
	shl	ecx, 8
	and	edx, 255				; 000000ffH
	or	ecx, edx

; 178  : 						i += 2;

	add	esi, 2

; 179  : 				  } else {

	jmp	SHORT $LN1@extractTex
$LN2@extractTex:

; 180  : 						u = s1->getChar(i) & 0xff;

	movsx	ecx, BYTE PTR [ecx+esi]
	and	ecx, 255				; 000000ffH

; 181  : 						++i;

	inc	esi
$LN1@extractTex:

; 182  : 				  }
; 183  : 				  ret[j] = u;

	mov	WORD PTR [ebx+eax*2], cx

; 184  : 				  j++;

	inc	eax
	cmp	esi, DWORD PTR [edi]
	jl	SHORT $LN4@extractTex
$LN3@extractTex:

; 185  : 			}
; 186  : 
; 187  : 			ret[j]='\0';

	xor	edx, edx

; 188  : 			
; 189  : 			delete s1;

	mov	ecx, edi
	mov	WORD PTR [ebx+eax*2], dx
	call	??1GString@@QAE@XZ			; GString::~GString
	push	edi
	call	??3@YAXPAX@Z				; operator delete

; 190  : 			delete txt;	

	mov	esi, DWORD PTR _txt$[esp+68]
	add	esp, 4
	test	esi, esi
	je	SHORT $LN14@extractTex
	mov	ecx, esi
	call	??1TextPage@@QAE@XZ			; TextPage::~TextPage
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN14@extractTex:

; 191  : 		}
; 192  : 	}
; 193  : 	delete s1;

	mov	ecx, edi
	call	??1GString@@QAE@XZ			; GString::~GString
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN53@extractTex:

; 194  : 	return EmptyChar;
; 195  : }

	pop	edi
	pop	esi
	mov	eax, OFFSET _EmptyChar
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?extractText@PDFPageInterop@@QAEPA_WHHHH@Z ENDP		; PDFPageInterop::extractText
END
