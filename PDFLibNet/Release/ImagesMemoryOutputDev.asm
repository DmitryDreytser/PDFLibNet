; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\cygwin\home\uejima\PDFLibNet\libAFPDFLib\ImagesMemoryOutputDev.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat


PUBLIC	?drawImage@ImagesMemoryOutputDev@@UAEXPAVGfxState@@PAVObject@@PAVStream@@HHPAVGfxImageColorMap@@PAHH@Z ; ImagesMemoryOutputDev::drawImage
PUBLIC	?drawImageMask@ImagesMemoryOutputDev@@UAEXPAVGfxState@@PAVObject@@PAVStream@@HHHH@Z ; ImagesMemoryOutputDev::drawImageMask
PUBLIC	??_R4ImagesMemoryOutputDev@@6B@			; ImagesMemoryOutputDev::`RTTI Complete Object Locator'
PUBLIC	??_R3ImagesMemoryOutputDev@@8			; ImagesMemoryOutputDev::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ImagesMemoryOutputDev@@8			; ImagesMemoryOutputDev::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ImagesMemoryOutputDev@@8		; ImagesMemoryOutputDev::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVImagesMemoryOutputDev@@@8		; ImagesMemoryOutputDev `RTTI Type Descriptor'
PUBLIC	??0?$DynArray@UImageInfo@@@@QAE@XZ		; DynArray<ImageInfo>::DynArray<ImageInfo>
PUBLIC	??1?$DynArray@UImageInfo@@@@QAE@XZ		; DynArray<ImageInfo>::~DynArray<ImageInfo>
PUBLIC	?Clear@?$DynArray@UImageInfo@@@@QAEXXZ		; DynArray<ImageInfo>::Clear
PUBLIC	?isOk@ImagesMemoryOutputDev@@UAEHXZ		; ImagesMemoryOutputDev::isOk
PUBLIC	?interpretType3Chars@ImagesMemoryOutputDev@@UAEHXZ ; ImagesMemoryOutputDev::interpretType3Chars
PUBLIC	?needNonText@ImagesMemoryOutputDev@@UAEHXZ	; ImagesMemoryOutputDev::needNonText
PUBLIC	?upsideDown@ImagesMemoryOutputDev@@UAEHXZ	; ImagesMemoryOutputDev::upsideDown
PUBLIC	?useDrawChar@ImagesMemoryOutputDev@@UAEHXZ	; ImagesMemoryOutputDev::useDrawChar
PUBLIC	??_GImagesMemoryOutputDev@@UAEPAXI@Z		; ImagesMemoryOutputDev::`scalar deleting destructor'
PUBLIC	??_GImageStream@@QAEPAXI@Z			; ImageStream::`scalar deleting destructor'
PUBLIC	?getRawStream@DCTStream@@QAEPAVStream@@XZ	; DCTStream::getRawStream
PUBLIC	?getNumPixelComps@GfxImageColorMap@@QAEHXZ	; GfxImageColorMap::getNumPixelComps
PUBLIC	?getBits@GfxImageColorMap@@QAEHXZ		; GfxImageColorMap::getBits
PUBLIC	?Add@?$DynArray@UImageInfo@@@@QAEXABUImageInfo@@@Z ; DynArray<ImageInfo>::Add
PUBLIC	??A?$DynArray@UImageInfo@@@@QAEAAUImageInfo@@I@Z ; DynArray<ImageInfo>::operator[]
PUBLIC	?GetSize@?$DynArray@UImageInfo@@@@QAEIXZ	; DynArray<ImageInfo>::GetSize
PUBLIC	?GetCount@?$DynArray@UImageInfo@@@@QAEIXZ	; DynArray<ImageInfo>::GetCount
PUBLIC	??_C@_0BL@BOIEBPCB@Memory?5allocation?5failure?$CB?$AA@ ; `string'
PUBLIC	??_R0PAD@8					; char * `RTTI Type Descriptor'
PUBLIC	__CT??_R0PAD@84
PUBLIC	__CT??_R0PAX@84
PUBLIC	__CTA2PAD
PUBLIC	__TI2PAD
PUBLIC	??_C@_0BA@DAHFKGND@Copy?5Stream?5PBM?$AA@	; `string'
PUBLIC	??_R0?AW4exception@?$DynArray@UImageInfo@@@@@8	; enum DynArray<ImageInfo>::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AW4exception@?$DynArray@UImageInfo@@@@@84
PUBLIC	__CTA1?AW4exception@?$DynArray@UImageInfo@@@@
PUBLIC	__TI1?AW4exception@?$DynArray@UImageInfo@@@@
PUBLIC	??_7ImagesMemoryOutputDev@@6B@			; ImagesMemoryOutputDev::`vftable'
EXTRN	??_EImagesMemoryOutputDev@@UAEPAXI@Z:PROC	; ImagesMemoryOutputDev::`vector deleting destructor'
;	COMDAT ??_7ImagesMemoryOutputDev@@6B@
CONST	SEGMENT
??_7ImagesMemoryOutputDev@@6B@ DD FLAT:??_R4ImagesMemoryOutputDev@@6B@ ; ImagesMemoryOutputDev::`vftable'
	DD	FLAT:??_EImagesMemoryOutputDev@@UAEPAXI@Z
	DD	FLAT:?upsideDown@ImagesMemoryOutputDev@@UAEHXZ
	DD	FLAT:?useDrawChar@ImagesMemoryOutputDev@@UAEHXZ
	DD	FLAT:?useTilingPatternFill@OutputDev@@UAEHXZ
	DD	FLAT:?useShadedFills@OutputDev@@UAEHXZ
	DD	FLAT:?useDrawForm@OutputDev@@UAEHXZ
	DD	FLAT:?interpretType3Chars@ImagesMemoryOutputDev@@UAEHXZ
	DD	FLAT:?needNonText@ImagesMemoryOutputDev@@UAEHXZ
	DD	FLAT:?setDefaultCTM@OutputDev@@UAEXPAN@Z
	DD	FLAT:?checkPageSlice@OutputDev@@UAEHPAVPage@@NNHHHHHHHHPAVCatalog@@P6AHPAX@Z2@Z
	DD	FLAT:?startPage@OutputDev@@UAEXHPAVGfxState@@@Z
	DD	FLAT:?endPage@OutputDev@@UAEXXZ
	DD	FLAT:?dump@OutputDev@@UAEXXZ
	DD	FLAT:?cvtDevToUser@OutputDev@@UAEXNNPAN0@Z
	DD	FLAT:?cvtUserToDev@OutputDev@@UAEXNNPAH0@Z
	DD	FLAT:?saveState@OutputDev@@UAEXPAVGfxState@@@Z
	DD	FLAT:?restoreState@OutputDev@@UAEXPAVGfxState@@@Z
	DD	FLAT:?updateAll@OutputDev@@UAEXPAVGfxState@@@Z
	DD	FLAT:?updateCTM@OutputDev@@UAEXPAVGfxState@@NNNNNN@Z
	DD	FLAT:?updateLineDash@OutputDev@@UAEXPAVGfxState@@@Z
	DD	FLAT:?updateFlatness@OutputDev@@UAEXPAVGfxState@@@Z
	DD	FLAT:?updateLineJoin@OutputDev@@UAEXPAVGfxState@@@Z
	DD	FLAT:?updateLineCap@OutputDev@@UAEXPAVGfxState@@@Z
	DD	FLAT:?updateMiterLimit@OutputDev@@UAEXPAVGfxState@@@Z
	DD	FLAT:?updateLineWidth@OutputDev@@UAEXPAVGfxState@@@Z
	DD	FLAT:?updateStrokeAdjust@OutputDev@@UAEXPAVGfxState@@@Z
	DD	FLAT:?updateFillColorSpace@OutputDev@@UAEXPAVGfxState@@@Z
	DD	FLAT:?updateStrokeColorSpace@OutputDev@@UAEXPAVGfxState@@@Z
	DD	FLAT:?updateFillColor@OutputDev@@UAEXPAVGfxState@@@Z
	DD	FLAT:?updateStrokeColor@OutputDev@@UAEXPAVGfxState@@@Z
	DD	FLAT:?updateBlendMode@OutputDev@@UAEXPAVGfxState@@@Z
	DD	FLAT:?updateFillOpacity@OutputDev@@UAEXPAVGfxState@@@Z
	DD	FLAT:?updateStrokeOpacity@OutputDev@@UAEXPAVGfxState@@@Z
	DD	FLAT:?updateFillOverprint@OutputDev@@UAEXPAVGfxState@@@Z
	DD	FLAT:?updateStrokeOverprint@OutputDev@@UAEXPAVGfxState@@@Z
	DD	FLAT:?updateTransfer@OutputDev@@UAEXPAVGfxState@@@Z
	DD	FLAT:?updateFont@OutputDev@@UAEXPAVGfxState@@@Z
	DD	FLAT:?updateTextMat@OutputDev@@UAEXPAVGfxState@@@Z
	DD	FLAT:?updateCharSpace@OutputDev@@UAEXPAVGfxState@@@Z
	DD	FLAT:?updateRender@OutputDev@@UAEXPAVGfxState@@@Z
	DD	FLAT:?updateRise@OutputDev@@UAEXPAVGfxState@@@Z
	DD	FLAT:?updateWordSpace@OutputDev@@UAEXPAVGfxState@@@Z
	DD	FLAT:?updateHorizScaling@OutputDev@@UAEXPAVGfxState@@@Z
	DD	FLAT:?updateTextPos@OutputDev@@UAEXPAVGfxState@@@Z
	DD	FLAT:?updateTextShift@OutputDev@@UAEXPAVGfxState@@N@Z
	DD	FLAT:?stroke@OutputDev@@UAEXPAVGfxState@@@Z
	DD	FLAT:?fill@OutputDev@@UAEXPAVGfxState@@@Z
	DD	FLAT:?eoFill@OutputDev@@UAEXPAVGfxState@@@Z
	DD	FLAT:?tilingPatternFill@OutputDev@@UAEXPAVGfxState@@PAVObject@@HPAVDict@@PAN3HHHHNN@Z
	DD	FLAT:?functionShadedFill@OutputDev@@UAEHPAVGfxState@@PAVGfxFunctionShading@@@Z
	DD	FLAT:?axialShadedFill@OutputDev@@UAEHPAVGfxState@@PAVGfxAxialShading@@@Z
	DD	FLAT:?radialShadedFill@OutputDev@@UAEHPAVGfxState@@PAVGfxRadialShading@@@Z
	DD	FLAT:?clip@OutputDev@@UAEXPAVGfxState@@@Z
	DD	FLAT:?eoClip@OutputDev@@UAEXPAVGfxState@@@Z
	DD	FLAT:?clipToStrokePath@OutputDev@@UAEXPAVGfxState@@@Z
	DD	FLAT:?beginStringOp@OutputDev@@UAEXPAVGfxState@@@Z
	DD	FLAT:?endStringOp@OutputDev@@UAEXPAVGfxState@@@Z
	DD	FLAT:?beginString@OutputDev@@UAEXPAVGfxState@@PAVGString@@@Z
	DD	FLAT:?endString@OutputDev@@UAEXPAVGfxState@@@Z
	DD	FLAT:?drawChar@OutputDev@@UAEXPAVGfxState@@NNNNNNIHPAIH@Z
	DD	FLAT:?drawString@OutputDev@@UAEXPAVGfxState@@PAVGString@@@Z
	DD	FLAT:?beginType3Char@OutputDev@@UAEHPAVGfxState@@NNNNIPAIH@Z
	DD	FLAT:?endType3Char@OutputDev@@UAEXPAVGfxState@@@Z
	DD	FLAT:?endTextObject@OutputDev@@UAEXPAVGfxState@@@Z
	DD	FLAT:?drawImageMask@ImagesMemoryOutputDev@@UAEXPAVGfxState@@PAVObject@@PAVStream@@HHHH@Z
	DD	FLAT:?drawImage@ImagesMemoryOutputDev@@UAEXPAVGfxState@@PAVObject@@PAVStream@@HHPAVGfxImageColorMap@@PAHH@Z
	DD	FLAT:?drawMaskedImage@OutputDev@@UAEXPAVGfxState@@PAVObject@@PAVStream@@HHPAVGfxImageColorMap@@2HHH@Z
	DD	FLAT:?drawSoftMaskedImage@OutputDev@@UAEXPAVGfxState@@PAVObject@@PAVStream@@HHPAVGfxImageColorMap@@2HH3@Z
	DD	FLAT:?type3D0@OutputDev@@UAEXPAVGfxState@@NN@Z
	DD	FLAT:?type3D1@OutputDev@@UAEXPAVGfxState@@NNNNNN@Z
	DD	FLAT:?drawForm@OutputDev@@UAEXURef@@@Z
	DD	FLAT:?psXObject@OutputDev@@UAEXPAVStream@@0@Z
	DD	FLAT:?beginTransparencyGroup@OutputDev@@UAEXPAVGfxState@@PANPAVGfxColorSpace@@HHH@Z
	DD	FLAT:?endTransparencyGroup@OutputDev@@UAEXPAVGfxState@@@Z
	DD	FLAT:?paintTransparencyGroup@OutputDev@@UAEXPAVGfxState@@PAN@Z
	DD	FLAT:?setSoftMask@OutputDev@@UAEXPAVGfxState@@PANHPAVFunction@@PAUGfxColor@@@Z
	DD	FLAT:?clearSoftMask@OutputDev@@UAEXPAVGfxState@@@Z
	DD	FLAT:?processLink@OutputDev@@UAEXPAVLink@@PAVCatalog@@@Z
	DD	FLAT:?getVectorAntialias@OutputDev@@UAEHXZ
	DD	FLAT:?setVectorAntialias@OutputDev@@UAEXH@Z
	DD	FLAT:?isOk@ImagesMemoryOutputDev@@UAEHXZ
CONST	ENDS
;	COMDAT ??_R4ImagesMemoryOutputDev@@6B@
rdata$r	SEGMENT
??_R4ImagesMemoryOutputDev@@6B@ DD 00H			; ImagesMemoryOutputDev::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVImagesMemoryOutputDev@@@8
	DD	FLAT:??_R3ImagesMemoryOutputDev@@8
rdata$r	ENDS
;	COMDAT ??_R3ImagesMemoryOutputDev@@8
rdata$r	SEGMENT
??_R3ImagesMemoryOutputDev@@8 DD 00H			; ImagesMemoryOutputDev::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ImagesMemoryOutputDev@@8
rdata$r	ENDS
;	COMDAT ??_R2ImagesMemoryOutputDev@@8
rdata$r	SEGMENT
??_R2ImagesMemoryOutputDev@@8 DD FLAT:??_R1A@?0A@EA@ImagesMemoryOutputDev@@8 ; ImagesMemoryOutputDev::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@OutputDev@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ImagesMemoryOutputDev@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ImagesMemoryOutputDev@@8 DD FLAT:??_R0?AVImagesMemoryOutputDev@@@8 ; ImagesMemoryOutputDev::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ImagesMemoryOutputDev@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVImagesMemoryOutputDev@@@8
_DATA	SEGMENT
??_R0?AVImagesMemoryOutputDev@@@8 DD FLAT:??_7type_info@@6B@ ; ImagesMemoryOutputDev `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVImagesMemoryOutputDev@@', 00H
_DATA	ENDS
;	COMDAT __TI1?AW4exception@?$DynArray@UImageInfo@@@@
xdata$x	SEGMENT
__TI1?AW4exception@?$DynArray@UImageInfo@@@@ DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__CTA1?AW4exception@?$DynArray@UImageInfo@@@@
xdata$x	ENDS
;	COMDAT __CTA1?AW4exception@?$DynArray@UImageInfo@@@@
xdata$x	SEGMENT
__CTA1?AW4exception@?$DynArray@UImageInfo@@@@ DD 01H
	DD	FLAT:__CT??_R0?AW4exception@?$DynArray@UImageInfo@@@@@84
xdata$x	ENDS
;	COMDAT __CT??_R0?AW4exception@?$DynArray@UImageInfo@@@@@84
xdata$x	SEGMENT
__CT??_R0?AW4exception@?$DynArray@UImageInfo@@@@@84 DD 01H
	DD	FLAT:??_R0?AW4exception@?$DynArray@UImageInfo@@@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT ??_R0?AW4exception@?$DynArray@UImageInfo@@@@@8
_DATA	SEGMENT
??_R0?AW4exception@?$DynArray@UImageInfo@@@@@8 DD FLAT:??_7type_info@@6B@ ; enum DynArray<ImageInfo>::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AW4exception@?$DynArray@UImageInfo@@@@', 00H
_DATA	ENDS
;	COMDAT ??_C@_0BA@DAHFKGND@Copy?5Stream?5PBM?$AA@
CONST	SEGMENT
??_C@_0BA@DAHFKGND@Copy?5Stream?5PBM?$AA@ DB 'Copy Stream PBM', 00H ; `string'
CONST	ENDS
;	COMDAT __TI2PAD
xdata$x	SEGMENT
__TI2PAD DD	00H
	DD	00H
	DD	00H
	DD	FLAT:__CTA2PAD
xdata$x	ENDS
;	COMDAT __CTA2PAD
xdata$x	SEGMENT
__CTA2PAD DD	02H
	DD	FLAT:__CT??_R0PAD@84
	DD	FLAT:__CT??_R0PAX@84
xdata$x	ENDS
;	COMDAT __CT??_R0PAX@84
xdata$x	SEGMENT
__CT??_R0PAX@84 DD 01H
	DD	FLAT:??_R0PAX@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT __CT??_R0PAD@84
xdata$x	SEGMENT
__CT??_R0PAD@84 DD 01H
	DD	FLAT:??_R0PAD@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT ??_R0PAD@8
_DATA	SEGMENT
??_R0PAD@8 DD	FLAT:??_7type_info@@6B@			; char * `RTTI Type Descriptor'
	DD	00H
	DB	'.PAD', 00H
_DATA	ENDS
;	COMDAT ??_C@_0BL@BOIEBPCB@Memory?5allocation?5failure?$CB?$AA@
CONST	SEGMENT
??_C@_0BL@BOIEBPCB@Memory?5allocation?5failure?$CB?$AA@ DB 'Memory alloca'
	DB	'tion failure!', 00H				; `string'
; Function compile flags: /Ogtpy
; File c:\cygwin\home\uejima\pdflibnet\libafpdflib\dynarray.h
;	COMDAT ?Clear@?$DynArray@UImageInfo@@@@QAEXXZ
_TEXT	SEGMENT
?Clear@?$DynArray@UImageInfo@@@@QAEXXZ PROC		; DynArray<ImageInfo>::Clear, COMDAT
; _this$ = esi

; 150  :     size = 0; 
; 151  : 	array = (T *)realloc(array, sizeof(T)*dyn_array_step); 

	mov	eax, DWORD PTR [esi]
	push	4608					; 00001200H
	push	eax
	mov	DWORD PTR [esi+4], 0
	call	DWORD PTR __imp__realloc
	add	esp, 8
	mov	DWORD PTR [esi], eax

; 152  : 				  // set initial memory size again 
; 153  : 	realsize = dyn_array_step;

	mov	DWORD PTR [esi+8], 128			; 00000080H

; 154  : }

	ret	0
?Clear@?$DynArray@UImageInfo@@@@QAEXXZ ENDP		; DynArray<ImageInfo>::Clear
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetSize@?$DynArray@UImageInfo@@@@QAEIXZ
_TEXT	SEGMENT
?GetSize@?$DynArray@UImageInfo@@@@QAEIXZ PROC		; DynArray<ImageInfo>::GetSize, COMDAT
; _this$ = eax

; 102  :     return size; // simply return size

	mov	eax, DWORD PTR [eax+4]

; 103  : }

	ret	0
?GetSize@?$DynArray@UImageInfo@@@@QAEIXZ ENDP		; DynArray<ImageInfo>::GetSize
_TEXT	ENDS
EXTRN	__CxxThrowException@8:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?Add@?$DynArray@UImageInfo@@@@QAEXABUImageInfo@@@Z
_TEXT	SEGMENT
$T159718 = 8						; size = 4
_item$ = 8						; size = 4
?Add@?$DynArray@UImageInfo@@@@QAEXABUImageInfo@@@Z PROC	; DynArray<ImageInfo>::Add, COMDAT
; _this$ = eax

; 170  : {

	push	esi
	mov	esi, eax

; 171  :     size++;

	inc	DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+4]

; 172  :  
; 173  :     if (size > realsize)

	mov	eax, DWORD PTR [esi+8]
	cmp	ecx, eax
	jbe	SHORT $LN1@Add

; 174  :     {
; 175  : 		realsize *= dyn_array_mult;
; 176  :  
; 177  : 		array = (T *)realloc(array, sizeof(T)*realsize);

	mov	ecx, DWORD PTR [esi]
	add	eax, eax
	mov	DWORD PTR [esi+8], eax
	lea	eax, DWORD PTR [eax+eax*8]
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	call	DWORD PTR __imp__realloc
	add	esp, 8
	mov	DWORD PTR [esi], eax

; 178  :  
; 179  : 		if (array == NULL)

	test	eax, eax
	jne	SHORT $LN1@Add

; 180  : 			throw MEMFAIL;

	push	OFFSET __TI1?AW4exception@?$DynArray@UImageInfo@@@@
	lea	edx, DWORD PTR $T159718[esp+4]
	push	edx
	mov	DWORD PTR $T159718[esp+8], eax
	call	__CxxThrowException@8
$LN6@Add:
$LN1@Add:

; 181  :     }
; 182  :  
; 183  : 	array[size-1] = item;

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	mov	esi, DWORD PTR _item$[esp]
	push	edi
	lea	eax, DWORD PTR [eax+eax*8]
	lea	edi, DWORD PTR [ecx+eax*4-36]
	mov	ecx, 9
	rep movsd
	pop	edi
	pop	esi

; 184  : }

	ret	4
$LN5@Add:
?Add@?$DynArray@UImageInfo@@@@QAEXABUImageInfo@@@Z ENDP	; DynArray<ImageInfo>::Add
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??A?$DynArray@UImageInfo@@@@QAEAAUImageInfo@@I@Z
_TEXT	SEGMENT
??A?$DynArray@UImageInfo@@@@QAEAAUImageInfo@@I@Z PROC	; DynArray<ImageInfo>::operator[], COMDAT
; _this$ = ecx
; _index$ = eax

; 165  :     return array[index]; // return array element 

	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+eax*8]
	lea	eax, DWORD PTR [edx+eax*4]

; 166  : }

	ret	0
??A?$DynArray@UImageInfo@@@@QAEAAUImageInfo@@I@Z ENDP	; DynArray<ImageInfo>::operator[]
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$DynArray@UImageInfo@@@@QAE@XZ
_TEXT	SEGMENT
??1?$DynArray@UImageInfo@@@@QAE@XZ PROC			; DynArray<ImageInfo>::~DynArray<ImageInfo>, COMDAT
; _this$ = esi

; 61   :     if (array)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN1@DynArray

; 62   :     {
; 63   :     	free(array); // Freeing memory 

	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4

; 64   :     	array = NULL;

	mov	DWORD PTR [esi], 0
$LN1@DynArray:

; 65   :     }
; 66   : }

	ret	0
??1?$DynArray@UImageInfo@@@@QAE@XZ ENDP			; DynArray<ImageInfo>::~DynArray<ImageInfo>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$DynArray@UImageInfo@@@@QAE@XZ
_TEXT	SEGMENT
$T159730 = -4						; size = 4
??0?$DynArray@UImageInfo@@@@QAE@XZ PROC			; DynArray<ImageInfo>::DynArray<ImageInfo>, COMDAT
; _this$ = esi

; 47   : {

	push	ecx

; 48   :     realsize = dyn_array_step; // First, allocate step 
; 49   : 							   // for dyn_array_step items
; 50   :     size = 0;
; 51   :     array = (T *)malloc(realsize*sizeof(T));

	push	4608					; 00001200H
	mov	DWORD PTR [esi+8], 128			; 00000080H
	mov	DWORD PTR [esi+4], 0
	call	DWORD PTR __imp__malloc
	add	esp, 4
	mov	DWORD PTR [esi], eax

; 52   :  
; 53   :     if (array == NULL)

	test	eax, eax
	jne	SHORT $LN1@DynArray@2

; 54   : 		throw MEMFAIL;

	mov	DWORD PTR $T159730[esp+4], eax
	push	OFFSET __TI1?AW4exception@?$DynArray@UImageInfo@@@@
	lea	eax, DWORD PTR $T159730[esp+8]
	push	eax
	call	__CxxThrowException@8
$LN5@DynArray@2:
$LN1@DynArray@2:

; 55   : }

	mov	eax, esi
	pop	ecx
	ret	0
$LN4@DynArray@2:
??0?$DynArray@UImageInfo@@@@QAE@XZ ENDP			; DynArray<ImageInfo>::DynArray<ImageInfo>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetCount@?$DynArray@UImageInfo@@@@QAEIXZ
_TEXT	SEGMENT
?GetCount@?$DynArray@UImageInfo@@@@QAEIXZ PROC		; DynArray<ImageInfo>::GetCount, COMDAT
; _this$ = eax

; 17   : 		return this->GetSize();

	mov	eax, DWORD PTR [eax+4]

; 18   : 	}

	ret	0
?GetCount@?$DynArray@UImageInfo@@@@QAEIXZ ENDP		; DynArray<ImageInfo>::GetCount
_TEXT	ENDS
PUBLIC	?getImageName@ImagesMemoryOutputDev@@QAEPADH@Z	; ImagesMemoryOutputDev::getImageName
; Function compile flags: /Ogtpy
; File c:\cygwin\home\uejima\pdflibnet\libafpdflib\imagesmemoryoutputdev.cpp
;	COMDAT ?getImageName@ImagesMemoryOutputDev@@QAEPADH@Z
_TEXT	SEGMENT
?getImageName@ImagesMemoryOutputDev@@QAEPADH@Z PROC	; ImagesMemoryOutputDev::getImageName, COMDAT
; _this$ = ecx
; _imgIndex$ = eax

; 296  : 		if(imgIndex>=0 && imgIndex<_Images.GetCount()){

	test	eax, eax
	jl	SHORT $LN1@getImageNa
	cmp	eax, DWORD PTR [ecx+108]
	jae	SHORT $LN1@getImageNa

; 297  : 		ImageInfo *img=&_Images[imgIndex];
; 298  : 		return img->name;

	mov	ecx, DWORD PTR [ecx+104]
	lea	eax, DWORD PTR [eax+eax*8]
	mov	eax, DWORD PTR [ecx+eax*4+4]

; 301  : }

	ret	0
$LN1@getImageNa:

; 299  : 	}
; 300  : 	return 0;

	xor	eax, eax

; 301  : }

	ret	0
?getImageName@ImagesMemoryOutputDev@@QAEPADH@Z ENDP	; ImagesMemoryOutputDev::getImageName
_TEXT	ENDS
PUBLIC	?getImageWidth@ImagesMemoryOutputDev@@QAEHH@Z	; ImagesMemoryOutputDev::getImageWidth
; Function compile flags: /Ogtpy
;	COMDAT ?getImageWidth@ImagesMemoryOutputDev@@QAEHH@Z
_TEXT	SEGMENT
?getImageWidth@ImagesMemoryOutputDev@@QAEHH@Z PROC	; ImagesMemoryOutputDev::getImageWidth, COMDAT
; _this$ = ecx
; _imgIndex$ = eax

; 288  : 	if(imgIndex>=0 && imgIndex<_Images.GetCount()){

	test	eax, eax
	jl	SHORT $LN1@getImageWi
	cmp	eax, DWORD PTR [ecx+108]
	jae	SHORT $LN1@getImageWi

; 289  : 		ImageInfo *img=&_Images[imgIndex];
; 290  : 		return img->width;

	mov	ecx, DWORD PTR [ecx+104]
	lea	eax, DWORD PTR [eax+eax*8]
	mov	eax, DWORD PTR [ecx+eax*4+8]

; 293  : }

	ret	0
$LN1@getImageWi:

; 291  : 	}
; 292  : 	return 0;

	xor	eax, eax

; 293  : }

	ret	0
?getImageWidth@ImagesMemoryOutputDev@@QAEHH@Z ENDP	; ImagesMemoryOutputDev::getImageWidth
_TEXT	ENDS
PUBLIC	?getImageHeight@ImagesMemoryOutputDev@@QAEHH@Z	; ImagesMemoryOutputDev::getImageHeight
; Function compile flags: /Ogtpy
;	COMDAT ?getImageHeight@ImagesMemoryOutputDev@@QAEHH@Z
_TEXT	SEGMENT
?getImageHeight@ImagesMemoryOutputDev@@QAEHH@Z PROC	; ImagesMemoryOutputDev::getImageHeight, COMDAT
; _this$ = ecx
; _imgIndex$ = eax

; 280  : 	if(imgIndex>=0 && imgIndex<_Images.GetCount()){

	test	eax, eax
	jl	SHORT $LN1@getImageHe
	cmp	eax, DWORD PTR [ecx+108]
	jae	SHORT $LN1@getImageHe

; 281  : 		ImageInfo *img=&_Images[imgIndex];
; 282  : 		return img->height;

	mov	ecx, DWORD PTR [ecx+104]
	lea	eax, DWORD PTR [eax+eax*8]
	mov	eax, DWORD PTR [ecx+eax*4+12]

; 285  : }

	ret	0
$LN1@getImageHe:

; 283  : 	}
; 284  : 	return 0;

	xor	eax, eax

; 285  : }

	ret	0
?getImageHeight@ImagesMemoryOutputDev@@QAEHH@Z ENDP	; ImagesMemoryOutputDev::getImageHeight
_TEXT	ENDS
PUBLIC	?getImageType@ImagesMemoryOutputDev@@QAEHH@Z	; ImagesMemoryOutputDev::getImageType
; Function compile flags: /Ogtpy
;	COMDAT ?getImageType@ImagesMemoryOutputDev@@QAEHH@Z
_TEXT	SEGMENT
?getImageType@ImagesMemoryOutputDev@@QAEHH@Z PROC	; ImagesMemoryOutputDev::getImageType, COMDAT
; _this$ = ecx
; _imgIndex$ = eax

; 271  : 	if(imgIndex>=0 && imgIndex<_Images.GetCount()){

	test	eax, eax
	jl	SHORT $LN1@getImageTy
	cmp	eax, DWORD PTR [ecx+108]
	jae	SHORT $LN1@getImageTy

; 272  : 		ImageInfo *img=&_Images[imgIndex];
; 273  : 		return img->type;

	mov	ecx, DWORD PTR [ecx+104]
	lea	eax, DWORD PTR [eax+eax*8]
	mov	eax, DWORD PTR [ecx+eax*4+20]

; 276  : }

	ret	0
$LN1@getImageTy:

; 274  : 	}
; 275  : 	return -1;

	or	eax, -1

; 276  : }

	ret	0
?getImageType@ImagesMemoryOutputDev@@QAEHH@Z ENDP	; ImagesMemoryOutputDev::getImageType
_TEXT	ENDS
PUBLIC	?getImageSize@ImagesMemoryOutputDev@@QAEHH@Z	; ImagesMemoryOutputDev::getImageSize
; Function compile flags: /Ogtpy
;	COMDAT ?getImageSize@ImagesMemoryOutputDev@@QAEHH@Z
_TEXT	SEGMENT
?getImageSize@ImagesMemoryOutputDev@@QAEHH@Z PROC	; ImagesMemoryOutputDev::getImageSize, COMDAT
; _this$ = ecx
; _imgIndex$ = eax

; 263  : 	if(imgIndex>=0 && imgIndex<_Images.GetCount()){

	test	eax, eax
	jl	SHORT $LN1@getImageSi
	cmp	eax, DWORD PTR [ecx+108]
	jae	SHORT $LN1@getImageSi

; 264  : 		ImageInfo *img=&_Images[imgIndex];
; 265  : 		return img->size;

	mov	ecx, DWORD PTR [ecx+104]
	lea	eax, DWORD PTR [eax+eax*8]
	mov	eax, DWORD PTR [ecx+eax*4+24]

; 268  : }

	ret	0
$LN1@getImageSi:

; 266  : 	}
; 267  : 	return 0;

	xor	eax, eax

; 268  : }

	ret	0
?getImageSize@ImagesMemoryOutputDev@@QAEHH@Z ENDP	; ImagesMemoryOutputDev::getImageSize
_TEXT	ENDS
PUBLIC	?getImageBytes@ImagesMemoryOutputDev@@QAEPAEH@Z	; ImagesMemoryOutputDev::getImageBytes
; Function compile flags: /Ogtpy
;	COMDAT ?getImageBytes@ImagesMemoryOutputDev@@QAEPAEH@Z
_TEXT	SEGMENT
?getImageBytes@ImagesMemoryOutputDev@@QAEPAEH@Z PROC	; ImagesMemoryOutputDev::getImageBytes, COMDAT
; _this$ = ecx
; _imgIndex$ = eax

; 255  : 	if(imgIndex>=0 && imgIndex<_Images.GetCount()){

	test	eax, eax
	jl	SHORT $LN1@getImageBy
	cmp	eax, DWORD PTR [ecx+108]
	jae	SHORT $LN1@getImageBy

; 256  : 		ImageInfo *img=&_Images[imgIndex];
; 257  : 		return img->bytes;

	mov	ecx, DWORD PTR [ecx+104]
	lea	eax, DWORD PTR [eax+eax*8]
	mov	eax, DWORD PTR [ecx+eax*4]

; 260  : }

	ret	0
$LN1@getImageBy:

; 258  : 	}
; 259  : 	return 0;

	xor	eax, eax

; 260  : }

	ret	0
?getImageBytes@ImagesMemoryOutputDev@@QAEPAEH@Z ENDP	; ImagesMemoryOutputDev::getImageBytes
_TEXT	ENDS
PUBLIC	?getImageNumComps@ImagesMemoryOutputDev@@QAEHH@Z ; ImagesMemoryOutputDev::getImageNumComps
; Function compile flags: /Ogtpy
;	COMDAT ?getImageNumComps@ImagesMemoryOutputDev@@QAEHH@Z
_TEXT	SEGMENT
?getImageNumComps@ImagesMemoryOutputDev@@QAEHH@Z PROC	; ImagesMemoryOutputDev::getImageNumComps, COMDAT
; _this$ = ecx
; _imgIndex$ = eax

; 247  : 	if(imgIndex>=0 && imgIndex<_Images.GetCount()){

	test	eax, eax
	jl	SHORT $LN1@getImageNu
	cmp	eax, DWORD PTR [ecx+108]
	jae	SHORT $LN1@getImageNu

; 248  : 		ImageInfo *img=&_Images[imgIndex];
; 249  : 		return img->numcomps;

	mov	ecx, DWORD PTR [ecx+104]
	lea	eax, DWORD PTR [eax+eax*8]
	mov	eax, DWORD PTR [ecx+eax*4+28]

; 252  : }

	ret	0
$LN1@getImageNu:

; 250  : 	}
; 251  : 	return 0;

	xor	eax, eax

; 252  : }

	ret	0
?getImageNumComps@ImagesMemoryOutputDev@@QAEHH@Z ENDP	; ImagesMemoryOutputDev::getImageNumComps
_TEXT	ENDS
PUBLIC	?getImageCount@ImagesMemoryOutputDev@@QAEHXZ	; ImagesMemoryOutputDev::getImageCount
; Function compile flags: /Ogtpy
;	COMDAT ?getImageCount@ImagesMemoryOutputDev@@QAEHXZ
_TEXT	SEGMENT
?getImageCount@ImagesMemoryOutputDev@@QAEHXZ PROC	; ImagesMemoryOutputDev::getImageCount, COMDAT
; _this$ = eax

; 243  : 	return _Images.GetCount();

	mov	eax, DWORD PTR [eax+108]

; 244  : }

	ret	0
?getImageCount@ImagesMemoryOutputDev@@QAEHXZ ENDP	; ImagesMemoryOutputDev::getImageCount
; Function compile flags: /Ogtpy
; File c:\cygwin\home\uejima\pdflibnet\libafpdflib\imagesmemoryoutputdev.h
_TEXT	ENDS
;	COMDAT ?useDrawChar@ImagesMemoryOutputDev@@UAEHXZ
_TEXT	SEGMENT
?useDrawChar@ImagesMemoryOutputDev@@UAEHXZ PROC		; ImagesMemoryOutputDev::useDrawChar, COMDAT
; _this$ = ecx

; 68   :   virtual GBool useDrawChar() { return gFalse; }

	xor	eax, eax
	ret	0
?useDrawChar@ImagesMemoryOutputDev@@UAEHXZ ENDP		; ImagesMemoryOutputDev::useDrawChar
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?upsideDown@ImagesMemoryOutputDev@@UAEHXZ
_TEXT	SEGMENT
?upsideDown@ImagesMemoryOutputDev@@UAEHXZ PROC		; ImagesMemoryOutputDev::upsideDown, COMDAT
; _this$ = ecx

; 65   :   virtual GBool upsideDown() { return gTrue; }

	mov	eax, 1
	ret	0
?upsideDown@ImagesMemoryOutputDev@@UAEHXZ ENDP		; ImagesMemoryOutputDev::upsideDown
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?needNonText@ImagesMemoryOutputDev@@UAEHXZ
_TEXT	SEGMENT
?needNonText@ImagesMemoryOutputDev@@UAEHXZ PROC		; ImagesMemoryOutputDev::needNonText, COMDAT
; _this$ = ecx

; 59   :   virtual GBool needNonText() { return gTrue; }

	mov	eax, 1
	ret	0
?needNonText@ImagesMemoryOutputDev@@UAEHXZ ENDP		; ImagesMemoryOutputDev::needNonText
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?interpretType3Chars@ImagesMemoryOutputDev@@UAEHXZ
_TEXT	SEGMENT
?interpretType3Chars@ImagesMemoryOutputDev@@UAEHXZ PROC	; ImagesMemoryOutputDev::interpretType3Chars, COMDAT
; _this$ = ecx

; 56   :   virtual GBool interpretType3Chars() { return gFalse; }

	xor	eax, eax
	ret	0
?interpretType3Chars@ImagesMemoryOutputDev@@UAEHXZ ENDP	; ImagesMemoryOutputDev::interpretType3Chars
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?isOk@ImagesMemoryOutputDev@@UAEHXZ
_TEXT	SEGMENT
?isOk@ImagesMemoryOutputDev@@UAEHXZ PROC		; ImagesMemoryOutputDev::isOk, COMDAT
; _this$ = ecx

; 52   :   virtual GBool isOk() { return ok; }

	mov	eax, DWORD PTR [ecx+124]
	ret	0
?isOk@ImagesMemoryOutputDev@@UAEHXZ ENDP		; ImagesMemoryOutputDev::isOk
; Function compile flags: /Ogtpy
; File c:\cygwin\home\uejima\pdflibnet\xpdfwin\xpdf\gfxstate.h
_TEXT	ENDS
;	COMDAT ?getBits@GfxImageColorMap@@QAEHXZ
_TEXT	SEGMENT
?getBits@GfxImageColorMap@@QAEHXZ PROC			; GfxImageColorMap::getBits, COMDAT
; _this$ = eax

; 869  :   int getBits() { return bits; }

	mov	eax, DWORD PTR [eax+4]
	ret	0
?getBits@GfxImageColorMap@@QAEHXZ ENDP			; GfxImageColorMap::getBits
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getNumPixelComps@GfxImageColorMap@@QAEHXZ
_TEXT	SEGMENT
?getNumPixelComps@GfxImageColorMap@@QAEHXZ PROC		; GfxImageColorMap::getNumPixelComps, COMDAT
; _this$ = eax

; 868  :   int getNumPixelComps() { return nComps; }

	mov	eax, DWORD PTR [eax+8]
	ret	0
?getNumPixelComps@GfxImageColorMap@@QAEHXZ ENDP		; GfxImageColorMap::getNumPixelComps
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?colToByte@@YAEH@Z
_TEXT	SEGMENT
?colToByte@@YAEH@Z PROC					; colToByte, COMDAT
; _x$ = eax

; 76   :   // 255 * x + 0.5  =  256 * x - x + 0x8000
; 77   :   return (Guchar)(((x << 8) - x + 0x8000) >> 16);

	imul	eax, 255				; 000000ffH
	add	eax, 32768				; 00008000H
	sar	eax, 16					; 00000010H

; 78   : }

	ret	0
?colToByte@@YAEH@Z ENDP					; colToByte
; Function compile flags: /Ogtpy
; File c:\cygwin\home\uejima\pdflibnet\xpdfwin\xpdf\stream.h
_TEXT	ENDS
;	COMDAT ?getRawStream@DCTStream@@QAEPAVStream@@XZ
_TEXT	SEGMENT
?getRawStream@DCTStream@@QAEPAVStream@@XZ PROC		; DCTStream::getRawStream, COMDAT
; _this$ = eax

; 589  :   Stream *getRawStream() { return str; }

	mov	eax, DWORD PTR [eax+8]
	ret	0
?getRawStream@DCTStream@@QAEPAVStream@@XZ ENDP		; DCTStream::getRawStream
; Function compile flags: /Ogtpy
;	COMDAT ??_GImageStream@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GImageStream@@QAEPAXI@Z PROC				; ImageStream::`scalar deleting destructor', COMDAT
; _this$ = esi
	mov	ecx, esi
	call	??1ImageStream@@QAE@XZ			; ImageStream::~ImageStream
	test	BYTE PTR ___flags$[esp-4], 1
	je	SHORT $LN4@scalar@6
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@6:
	mov	eax, esi
	ret	4
??_GImageStream@@QAEPAXI@Z ENDP				; ImageStream::`scalar deleting destructor'
; Function compile flags: /Ogtpy
; File c:\cygwin\home\uejima\pdflibnet\libafpdflib\imagesmemoryoutputdev.cpp
_TEXT	ENDS
;	COMDAT ?drawImageMask@ImagesMemoryOutputDev@@UAEXPAVGfxState@@PAVObject@@PAVStream@@HHHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_state$ = 8						; size = 4
_ref$ = 12						; size = 4
_str$ = 16						; size = 4
tv266 = 20						; size = 4
_width$ = 20						; size = 4
_size$ = 24						; size = 4
_height$ = 24						; size = 4
_invert$ = 28						; size = 4
$T168004 = 32						; size = 4
_c$ = 32						; size = 4
$T168000 = 32						; size = 4
_inlineImg$ = 32					; size = 4
?drawImageMask@ImagesMemoryOutputDev@@UAEXPAVGfxState@@PAVObject@@PAVStream@@HHHH@Z PROC ; ImagesMemoryOutputDev::drawImageMask, COMDAT
; _this$ = ecx

; 30   : void ImagesMemoryOutputDev::drawImageMask(GfxState *state, Object *ref, Stream *str, int width, int height, GBool invert, GBool inlineImg) {

	push	ecx
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	ebp, ecx

; 31   : 	int c;
; 32   : 	int size, i;
; 33   : 	ImageInfo *img =new ImageInfo();

	push	36					; 00000024H
	mov	DWORD PTR _this$[esp+24], ebp
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN15@drawImageM
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax+20], ecx
	mov	DWORD PTR [eax+24], ecx
	mov	DWORD PTR [eax+28], ecx
	mov	DWORD PTR [eax+32], ecx
	mov	esi, eax
	jmp	SHORT $LN16@drawImageM
$LN15@drawImageM:
	xor	esi, esi
$LN16@drawImageM:

; 34   : 	int initBufSize=4096;
; 35   : 	int bufSize=initBufSize;

	mov	ebx, 4096				; 00001000H

; 36   : 	++imgNum;

	mov	edi, 1
	add	DWORD PTR [ebp+120], edi

; 37   : 	byte *buff=0;
; 38   : 	img->bytes =(byte *)malloc(bufSize);

	push	ebx
	call	DWORD PTR __imp__malloc
	add	esp, 4
	mov	DWORD PTR [esi], eax

; 39   : 	if(!img->bytes)

	test	eax, eax
	jne	SHORT $LN12@drawImageM

; 40   : 					throw "Memory allocation failure!";

	push	OFFSET __TI2PAD
	lea	eax, DWORD PTR $T168000[esp+20]
	push	eax
	mov	DWORD PTR $T168000[esp+24], OFFSET ??_C@_0BL@BOIEBPCB@Memory?5allocation?5failure?$CB?$AA@
	call	__CxxThrowException@8
$LN30@drawImageM:
$LN12@drawImageM:

; 41   : 	img->height=height;

	mov	ecx, DWORD PTR _height$[esp+16]

; 42   : 	img->width =width;

	mov	edx, DWORD PTR _width$[esp+16]
	mov	DWORD PTR [esi+12], ecx
	mov	DWORD PTR [esi+8], edx

; 43   : 	img->name=0;

	mov	DWORD PTR [esi+4], 0

; 44   : 	/*
; 45   : 	img->name=new char[strlen(ref->getName())];
; 46   : 	sprintf(img->name,"%s",ref->getName());*/
; 47   : 	img->ismask=true;

	mov	DWORD PTR [esi+32], edi

; 48   : 	img->index=imgNum;

	mov	eax, DWORD PTR [ebp+120]

; 49   : 	img->type=str->getKind() == strDCT && !inlineImg;

	mov	ebp, DWORD PTR _str$[esp+16]
	mov	DWORD PTR [esi+16], eax
	mov	edx, DWORD PTR [ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, ebp
	call	eax
	cmp	eax, 6
	jne	SHORT $LN28@drawImageM
	cmp	DWORD PTR _inlineImg$[esp+16], 0
	jne	SHORT $LN28@drawImageM
	mov	eax, edi
	jmp	SHORT $LN18@drawImageM
$LN28@drawImageM:
	xor	eax, eax
$LN18@drawImageM:

; 50   : 	int count=0;
; 51   :   // dump JPEG file
; 52   :   if (dumpJPEG && str->getKind() == strDCT && !inlineImg) {

	mov	ecx, DWORD PTR _this$[esp+20]
	xor	edi, edi
	mov	DWORD PTR [esi+20], eax
	cmp	DWORD PTR [ecx+116], edi
	je	$LN11@drawImageM
	mov	edx, DWORD PTR [ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, ebp
	call	eax
	cmp	eax, 6
	jne	$LN11@drawImageM
	cmp	DWORD PTR _inlineImg$[esp+16], edi
	jne	$LN11@drawImageM

; 53   :     
; 54   :     // initialize stream
; 55   :     str = ((DCTStream *)str)->getRawStream();

	mov	ebp, DWORD PTR [ebp+8]

; 56   :     str->reset();

	mov	edx, DWORD PTR [ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, ebp
	call	eax

; 57   : 		
; 58   :     // copy the stream
; 59   :     while ((c = str->getChar()) != EOF)

	mov	edx, DWORD PTR [ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, ebp
	call	eax
	mov	DWORD PTR _c$[esp+16], eax
	cmp	eax, -1
	je	SHORT $LN3@drawImageM
	npad	4
$LL10@drawImageM:

; 60   : 	{
; 61   : 		//Resize buffer preserving items
; 62   : 		if(count+1>bufSize){

	lea	eax, DWORD PTR [edi+1]
	cmp	eax, ebx
	mov	DWORD PTR tv266[esp+16], eax
	jle	SHORT $LN7@drawImageM

; 63   : 			bufSize+=initBufSize;
; 64   : 			img->bytes=(byte *)realloc(img->bytes,bufSize+1);

	mov	edx, DWORD PTR [esi]
	add	ebx, 4096				; 00001000H
	lea	ecx, DWORD PTR [ebx+1]
	push	ecx
	push	edx
	call	DWORD PTR __imp__realloc
	add	esp, 8
	mov	DWORD PTR [esi], eax

; 65   : 			if(!img->bytes)

	test	eax, eax
	je	$LN24@drawImageM
	mov	eax, DWORD PTR tv266[esp+16]
$LN7@drawImageM:

; 66   : 					throw "Memory allocation failure!";
; 67   : 		}
; 68   : 		img->bytes[count]=c;

	mov	ecx, DWORD PTR [esi]
	mov	dl, BYTE PTR _c$[esp+16]
	mov	BYTE PTR [edi+ecx], dl

; 69   : 		count++;

	mov	edi, eax
	mov	eax, DWORD PTR [ebp]
	mov	edx, DWORD PTR [eax+16]
	mov	ecx, ebp
	call	edx
	mov	DWORD PTR _c$[esp+16], eax
	cmp	eax, -1
	jne	SHORT $LL10@drawImageM
$LN3@drawImageM:

; 92   :     }
; 93   : 	img->size=count;

	mov	DWORD PTR [esi+24], edi

; 94   : 	img->numcomps=3;

	mov	DWORD PTR [esi+28], 3

; 95   :     str->close();

	mov	edx, DWORD PTR [ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, ebp
	call	eax

; 96   :   }
; 97   :   _Images.Add(*img);

	mov	eax, DWORD PTR _this$[esp+20]
	push	esi
	add	eax, 104				; 00000068H
	call	?Add@?$DynArray@UImageInfo@@@@QAEXABUImageInfo@@@Z ; DynArray<ImageInfo>::Add
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 98   : }

	pop	ecx
	ret	28					; 0000001cH
$LN11@drawImageM:

; 70   : 	}
; 71   : 	img->size=count;
; 72   : 	img->numcomps=3;
; 73   :     str->close();
; 74   :   // dump PBM file (P4)
; 75   :   } else {
; 76   :     // initialize stream
; 77   :     str->reset();

	mov	edx, DWORD PTR [ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, ebp
	call	eax

; 78   : 
; 79   :     // copy the stream
; 80   :     size = height * ((width + 7) / 8);

	mov	eax, DWORD PTR _width$[esp+16]
	add	eax, 7
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	imul	eax, DWORD PTR _height$[esp+16]
	mov	DWORD PTR _size$[esp+16], eax

; 81   :     for (i = 0; i < size; ++i) {

	test	eax, eax
	jle	SHORT $LN3@drawImageM
	npad	3
$LL5@drawImageM:

; 82   :       c = str->getChar();

	mov	edx, DWORD PTR [ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, ebp
	call	eax
	mov	DWORD PTR _c$[esp+16], eax

; 83   : 	  //Resize buffer preserving items
; 84   : 		if(count+1>bufSize){

	lea	eax, DWORD PTR [edi+1]
	cmp	eax, ebx
	mov	DWORD PTR tv266[esp+16], eax
	jle	SHORT $LN1@drawImageM

; 85   : 			bufSize+=initBufSize;
; 86   : 			img->bytes=(byte *)realloc(img->bytes,bufSize+1);

	mov	edx, DWORD PTR [esi]
	add	ebx, 4096				; 00001000H
	lea	ecx, DWORD PTR [ebx+1]
	push	ecx
	push	edx
	call	DWORD PTR __imp__realloc
	add	esp, 8
	mov	DWORD PTR [esi], eax

; 87   : 			if(!img->bytes)

	test	eax, eax
	je	SHORT $LN24@drawImageM
	mov	eax, DWORD PTR tv266[esp+16]
$LN1@drawImageM:

; 89   : 		}
; 90   : 		img->bytes[count]=c;

	mov	ecx, DWORD PTR [esi]
	mov	dl, BYTE PTR _c$[esp+16]
	mov	BYTE PTR [edi+ecx], dl

; 91   : 		count++;

	mov	edi, eax
	cmp	edi, DWORD PTR _size$[esp+16]
	jl	SHORT $LL5@drawImageM

; 87   : 			if(!img->bytes)

	jmp	$LN3@drawImageM
$LN24@drawImageM:

; 88   : 					throw "Memory allocation failure!";

	push	OFFSET __TI2PAD
	lea	eax, DWORD PTR $T168004[esp+20]
	push	eax
	mov	DWORD PTR $T168004[esp+24], OFFSET ??_C@_0BL@BOIEBPCB@Memory?5allocation?5failure?$CB?$AA@
	call	__CxxThrowException@8
$LN31@drawImageM:
$LN29@drawImageM:
	int	3
?drawImageMask@ImagesMemoryOutputDev@@UAEXPAVGfxState@@PAVObject@@PAVStream@@HHHH@Z ENDP ; ImagesMemoryOutputDev::drawImageMask
_TEXT	ENDS
PUBLIC	??1ImagesMemoryOutputDev@@UAE@XZ		; ImagesMemoryOutputDev::~ImagesMemoryOutputDev
; Function compile flags: /Ogtpy
;	COMDAT ??1ImagesMemoryOutputDev@@UAE@XZ
_TEXT	SEGMENT
??1ImagesMemoryOutputDev@@UAE@XZ PROC			; ImagesMemoryOutputDev::~ImagesMemoryOutputDev, COMDAT
; _this$ = ecx

; 24   : ImagesMemoryOutputDev::~ImagesMemoryOutputDev() {

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7ImagesMemoryOutputDev@@6B@

; 25   : 	_Images.Clear();

	mov	eax, DWORD PTR [esi+104]
	push	4608					; 00001200H
	push	eax
	mov	DWORD PTR [esi+108], 0
	call	DWORD PTR __imp__realloc
	add	esp, 8
	mov	DWORD PTR [esi+104], eax
	mov	DWORD PTR [esi+112], 128		; 00000080H

; 26   :   //gfree(fileName);
; 27   :   //gfree(fileRoot);
; 28   : }

	test	eax, eax
	je	SHORT $LN5@ImagesMemo
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	mov	DWORD PTR [esi+104], 0
$LN5@ImagesMemo:
	mov	ecx, esi
	pop	esi
	jmp	??1OutputDev@@UAE@XZ			; OutputDev::~OutputDev
??1ImagesMemoryOutputDev@@UAE@XZ ENDP			; ImagesMemoryOutputDev::~ImagesMemoryOutputDev
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GImagesMemoryOutputDev@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GImagesMemoryOutputDev@@UAEPAXI@Z PROC		; ImagesMemoryOutputDev::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7ImagesMemoryOutputDev@@6B@
	mov	eax, DWORD PTR [esi+104]
	push	4608					; 00001200H
	push	eax
	mov	DWORD PTR [esi+108], 0
	call	DWORD PTR __imp__realloc
	add	esp, 8
	mov	DWORD PTR [esi+104], eax
	mov	DWORD PTR [esi+112], 128		; 00000080H
	test	eax, eax
	je	SHORT $LN8@scalar@7
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	mov	DWORD PTR [esi+104], 0
$LN8@scalar@7:
	mov	ecx, esi
	call	??1OutputDev@@UAE@XZ			; OutputDev::~OutputDev
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN11@scalar@7
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN11@scalar@7:
	mov	eax, esi
	pop	esi
	ret	4
??_GImagesMemoryOutputDev@@UAEPAXI@Z ENDP		; ImagesMemoryOutputDev::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??0ImagesMemoryOutputDev@@QAE@XZ		; ImagesMemoryOutputDev::ImagesMemoryOutputDev
;	COMDAT xdata$x
; File c:\cygwin\home\uejima\pdflibnet\libafpdflib\dynarray.h
xdata$x	SEGMENT
__unwindtable$??0ImagesMemoryOutputDev@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0ImagesMemoryOutputDev@@QAE@XZ$0
__ehfuncinfo$??0ImagesMemoryOutputDev@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0ImagesMemoryOutputDev@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\cygwin\home\uejima\pdflibnet\libafpdflib\imagesmemoryoutputdev.cpp
xdata$x	ENDS
;	COMDAT ??0ImagesMemoryOutputDev@@QAE@XZ
_TEXT	SEGMENT
$T168064 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??0ImagesMemoryOutputDev@@QAE@XZ PROC			; ImagesMemoryOutputDev::ImagesMemoryOutputDev, COMDAT

; 18   : ImagesMemoryOutputDev::ImagesMemoryOutputDev() {

	push	-1
	push	__ehhandler$??0ImagesMemoryOutputDev@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[esp+24]
	mov	ecx, esi
	call	??0OutputDev@@QAE@XZ			; OutputDev::OutputDev
	xor	edi, edi
	mov	DWORD PTR __$EHRec$[esp+36], edi
	mov	DWORD PTR [esi], OFFSET ??_7ImagesMemoryOutputDev@@6B@
	push	4608					; 00001200H
	mov	DWORD PTR [esi+112], 128		; 00000080H
	mov	DWORD PTR [esi+108], edi
	call	DWORD PTR __imp__malloc
	add	esp, 4
	mov	DWORD PTR [esi+104], eax
	cmp	eax, edi
	jne	SHORT $LN5@ImagesMemo@2
	push	OFFSET __TI1?AW4exception@?$DynArray@UImageInfo@@@@
	lea	eax, DWORD PTR $T168064[esp+32]
	push	eax
	mov	DWORD PTR $T168064[esp+36], edi
	call	__CxxThrowException@8
$LN11@ImagesMemo@2:
$LN5@ImagesMemo@2:

; 19   :   dumpJPEG = gTrue;

	mov	eax, 1
	mov	DWORD PTR [esi+116], eax

; 20   :   imgNum = 0;
; 21   :   ok = gTrue;

	mov	DWORD PTR [esi+124], eax
	mov	DWORD PTR [esi+120], edi

; 22   : }

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	add	esp, 16					; 00000010H
	ret	4
$LN10@ImagesMemo@2:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0ImagesMemoryOutputDev@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp-4]
	jmp	??1OutputDev@@UAE@XZ			; OutputDev::~OutputDev
__ehhandler$??0ImagesMemoryOutputDev@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0ImagesMemoryOutputDev@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0ImagesMemoryOutputDev@@QAE@XZ ENDP			; ImagesMemoryOutputDev::ImagesMemoryOutputDev
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?drawImage@ImagesMemoryOutputDev@@UAEXPAVGfxState@@PAVObject@@PAVStream@@HHPAVGfxImageColorMap@@PAHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?drawImage@ImagesMemoryOutputDev@@UAEXPAVGfxState@@PAVObject@@PAVStream@@HHPAVGfxImageColorMap@@PAHH@Z$0
__ehfuncinfo$?drawImage@ImagesMemoryOutputDev@@UAEXPAVGfxState@@PAVObject@@PAVStream@@HHPAVGfxImageColorMap@@PAHH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?drawImage@ImagesMemoryOutputDev@@UAEXPAVGfxState@@PAVObject@@PAVStream@@HHPAVGfxImageColorMap@@PAHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?drawImage@ImagesMemoryOutputDev@@UAEXPAVGfxState@@PAVObject@@PAVStream@@HHPAVGfxImageColorMap@@PAHH@Z
_TEXT	SEGMENT
$T174292 = -180						; size = 4
_y$ = -180						; size = 4
$T174289 = -180						; size = 4
$T174287 = -180						; size = 4
_size$ = -180						; size = 4
$T174286 = -180						; size = 4
$T174285 = -180						; size = 4
tv463 = -176						; size = 4
$T174288 = -176						; size = 4
_p$ = -172						; size = 4
_c$ = -172						; size = 4
_bufSize$ = -168					; size = 4
_x$ = -164						; size = 4
_this$ = -160						; size = 4
_rgb$ = -156						; size = 12
_colr$10174 = -144					; size = 128
__$EHRec$ = -12						; size = 12
_state$ = 8						; size = 4
_ref$ = 12						; size = 4
_str$ = 16						; size = 4
_width$ = 20						; size = 4
_height$ = 24						; size = 4
_colorMap$ = 28						; size = 4
_maskColors$ = 32					; size = 4
_inlineImg$ = 36					; size = 4
?drawImage@ImagesMemoryOutputDev@@UAEXPAVGfxState@@PAVObject@@PAVStream@@HHPAVGfxImageColorMap@@PAHH@Z PROC ; ImagesMemoryOutputDev::drawImage, COMDAT
; _this$ = ecx

; 107  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	-1
	push	__ehhandler$?drawImage@ImagesMemoryOutputDev@@UAEXPAVGfxState@@PAVObject@@PAVStream@@HHPAVGfxImageColorMap@@PAHH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 168				; 000000a8H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+196]
	mov	DWORD PTR fs:0, eax
	mov	ebx, ecx
	mov	DWORD PTR _this$[esp+196], ebx

; 108  :   ImageStream *imgStr;
; 109  :   Guchar *p;
; 110  :   GfxRGB rgb;
; 111  :   int x, y;
; 112  :   int c;
; 113  :   int size, i;
; 114  : 
; 115  :   
; 116  : 	ImageInfo *img =new ImageInfo();

	push	36					; 00000024H
	call	??2@YAPAXI@Z				; operator new
	xor	edi, edi
	add	esp, 4
	cmp	eax, edi
	je	SHORT $LN30@drawImage
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax+20], ecx
	mov	DWORD PTR [eax+24], ecx
	mov	DWORD PTR [eax+28], ecx
	mov	DWORD PTR [eax+32], ecx
	mov	esi, eax
	jmp	SHORT $LN31@drawImage
$LN30@drawImage:
	xor	esi, esi
$LN31@drawImage:

; 117  : 	int initBufSize=16384;
; 118  : 	int bufSize=initBufSize;
; 119  : 	
; 120  : 	byte *buff=0;
; 121  : 	img->bytes =(byte *)malloc(bufSize);

	push	16384					; 00004000H
	mov	DWORD PTR _bufSize$[esp+200], 16384	; 00004000H
	call	DWORD PTR __imp__malloc
	add	esp, 4
	mov	DWORD PTR [esi], eax

; 122  : 	if(!img->bytes)

	cmp	eax, edi
	jne	SHORT $LN27@drawImage

; 123  : 		throw "Memory allocation failure!";

	push	OFFSET __TI2PAD
	lea	eax, DWORD PTR $T174285[esp+200]
	push	eax
	mov	DWORD PTR $T174285[esp+204], OFFSET ??_C@_0BL@BOIEBPCB@Memory?5allocation?5failure?$CB?$AA@
	call	__CxxThrowException@8
$LN92@drawImage:
$LN27@drawImage:

; 124  : 	img->height=height;

	mov	ecx, DWORD PTR _height$[ebp]

; 125  : 	img->width =width;

	mov	edx, DWORD PTR _width$[ebp]

; 126  : 
; 127  : 	
; 128  : 	img->name=0;
; 129  : 	//if(ref && ref->getName()){
; 130  : 		//img->name=new char[1024];
; 131  : 		//sprintf(img->name,"%s",ref->getName());
; 132  : 	//}
; 133  : 	img->ismask=true;

	mov	eax, 1
	mov	DWORD PTR [esi+12], ecx
	mov	DWORD PTR [esi+8], edx
	mov	DWORD PTR [esi+4], edi
	mov	DWORD PTR [esi+32], eax

; 134  : 	img->index=imgNum;

	mov	ecx, DWORD PTR [ebx+120]
	mov	DWORD PTR [esi+16], ecx

; 135  : 	img->type=0;

	mov	DWORD PTR [esi+20], edi

; 136  : 
; 137  : 	int count=0;
; 138  : 	
; 139  :   // dump JPEG file
; 140  :   if (dumpJPEG && str->getKind() == strDCT &&
; 141  :       (colorMap->getNumPixelComps() == 1 ||
; 142  :        colorMap->getNumPixelComps() == 3) &&
; 143  :       !inlineImg) {

	cmp	DWORD PTR [ebx+116], edi
	mov	ebx, DWORD PTR _colorMap$[ebp]
	je	$LN26@drawImage
	mov	ecx, DWORD PTR _str$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	eax, 6
	jne	$LN85@drawImage
	mov	eax, DWORD PTR [ebx+8]
	cmp	eax, 1
	je	SHORT $LN25@drawImage
	cmp	eax, 3
	jne	$LN85@drawImage
$LN25@drawImage:
	cmp	DWORD PTR _inlineImg$[ebp], edi
	jne	$LN85@drawImage

; 144  : 
; 145  :     // initialize stream
; 146  :     str = ((DCTStream *)str)->getRawStream();

	mov	ecx, DWORD PTR _str$[ebp]
	mov	ebx, DWORD PTR [ecx+8]

; 147  :     str->reset();

	mov	edx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, ebx
	call	eax

; 148  : 
; 149  :     // copy the stream
; 150  :     while ((c = str->getChar()) != EOF)

	mov	edx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, ebx
	call	eax
	mov	DWORD PTR _c$[esp+196], eax
	cmp	eax, -1
	je	SHORT $LN16@drawImage
$LN24@drawImage:

; 151  : 	{
; 152  : 		//Resize buffer preserving items
; 153  : 		if(count+1>bufSize){

	mov	ecx, DWORD PTR _bufSize$[esp+196]
	lea	eax, DWORD PTR [edi+1]
	cmp	eax, ecx
	mov	DWORD PTR tv463[esp+196], eax
	jle	SHORT $LN21@drawImage

; 154  : 			bufSize+=initBufSize;

	add	ecx, 16384				; 00004000H
	mov	DWORD PTR _bufSize$[esp+196], ecx

; 155  : 			img->bytes=(byte *)realloc(img->bytes,bufSize+1);

	inc	ecx
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	ecx
	call	DWORD PTR __imp__realloc
	add	esp, 8
	mov	DWORD PTR [esi], eax

; 156  : 			if(!img->bytes)

	test	eax, eax
	je	SHORT $LN78@drawImage
	mov	eax, DWORD PTR tv463[esp+196]
$LN21@drawImage:

; 158  : 		}
; 159  : 		img->bytes[count]=c;

	mov	edx, DWORD PTR [esi]
	mov	cl, BYTE PTR _c$[esp+196]
	mov	BYTE PTR [edi+edx], cl
	mov	edx, DWORD PTR [ebx]

; 160  : 		count++;

	mov	edi, eax
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, ebx
	call	eax
	mov	DWORD PTR _c$[esp+196], eax
	cmp	eax, -1
	jne	SHORT $LN24@drawImage
$LN16@drawImage:

; 186  : 		count++;
; 187  :     }
; 188  : 	img->size=count;

	mov	DWORD PTR [esi+24], edi

; 189  :     str->close();

	mov	edx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, ebx
	call	eax
	jmp	$LN34@drawImage
$LN78@drawImage:

; 157  : 					throw "Memory allocation failure!";

	push	OFFSET __TI2PAD
	lea	ecx, DWORD PTR $T174286[esp+200]
	push	ecx
	mov	DWORD PTR $T174286[esp+204], OFFSET ??_C@_0BL@BOIEBPCB@Memory?5allocation?5failure?$CB?$AA@
	call	__CxxThrowException@8
$LN93@drawImage:
$LN85@drawImage:

; 161  : 	}
; 162  : 	img->size=count;
; 163  :     str->close();
; 164  : 
; 165  :   // dump PBM file (P4)
; 166  :   } else if (colorMap->getNumPixelComps() == 1 &&

	mov	eax, 1
$LN26@drawImage:

; 167  : 	     colorMap->getBits() == 1) {

	cmp	DWORD PTR [ebx+8], eax
	jne	$LN19@drawImage
	cmp	DWORD PTR [ebx+4], eax
	jne	$LN19@drawImage

; 168  : 
; 169  : 	img->type=1;
; 170  :     // initialize stream
; 171  :     str->reset();

	mov	ebx, DWORD PTR _str$[ebp]
	mov	DWORD PTR [esi+20], eax
	mov	edx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, ebx
	call	eax

; 172  : 
; 173  :     // copy the stream
; 174  : 	fprintf(stderr,"Copy Stream PBM");

	push	OFFSET ??_C@_0BA@DAHFKGND@Copy?5Stream?5PBM?$AA@
	call	DWORD PTR __imp____iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	DWORD PTR __imp__fprintf

; 175  :     size = height * ((width + 7) / 8);

	mov	eax, DWORD PTR _width$[ebp]
	add	eax, 7
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	imul	eax, DWORD PTR _height$[ebp]
	add	esp, 8
	mov	DWORD PTR _size$[esp+196], eax

; 176  :     for (i = 0; i < size; ++i) {

	test	eax, eax
	jle	$LN16@drawImage
	npad	6
$LL18@drawImage:

; 177  : 		c  =str->getChar() ^ 0xff;

	mov	edx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, ebx
	call	eax
	mov	ebx, eax

; 178  : 		//Resize buffer preserving items
; 179  : 		if(count+1>bufSize){

	mov	eax, DWORD PTR _bufSize$[esp+196]
	lea	ecx, DWORD PTR [edi+1]
	xor	ebx, 255				; 000000ffH
	cmp	ecx, eax
	mov	DWORD PTR tv463[esp+196], ecx
	jle	SHORT $LN14@drawImage

; 180  : 			bufSize+=initBufSize;
; 181  : 			img->bytes=(byte *)realloc(img->bytes,bufSize+1);

	mov	ecx, DWORD PTR [esi]
	add	eax, 16384				; 00004000H
	mov	DWORD PTR _bufSize$[esp+196], eax
	inc	eax
	push	eax
	push	ecx
	call	DWORD PTR __imp__realloc
	add	esp, 8
	mov	DWORD PTR [esi], eax

; 182  : 			if(!img->bytes)

	test	eax, eax
	je	SHORT $LN79@drawImage
	mov	ecx, DWORD PTR tv463[esp+196]
$LN14@drawImage:

; 184  : 		}
; 185  : 		img->bytes[count]=c;

	mov	edx, DWORD PTR [esi]
	mov	BYTE PTR [edi+edx], bl

; 211  : 				if(!img->bytes)

	mov	ebx, DWORD PTR _str$[ebp]
	mov	edi, ecx
	cmp	edi, DWORD PTR _size$[esp+196]
	jl	SHORT $LL18@drawImage
	mov	DWORD PTR [esi+24], edi
	mov	edx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, ebx
	call	eax
	jmp	$LN34@drawImage
$LN79@drawImage:

; 183  : 					throw "Memory allocation failure!";

	push	OFFSET __TI2PAD
	lea	eax, DWORD PTR $T174287[esp+200]
	push	eax
	mov	DWORD PTR $T174287[esp+204], OFFSET ??_C@_0BL@BOIEBPCB@Memory?5allocation?5failure?$CB?$AA@
	call	__CxxThrowException@8
$LN94@drawImage:
$LN19@drawImage:

; 190  : 
; 191  :   // dump PPM file (P6)
; 192  :   } else {
; 193  : 	img->type=2;
; 194  :     // initialize stream
; 195  :     imgStr = new ImageStream(str, width, colorMap->getNumPixelComps(),colorMap->getBits());

	push	28					; 0000001cH
	mov	DWORD PTR [esi+20], 2
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T174289[esp+196], eax
	xor	ecx, ecx
	mov	DWORD PTR __$EHRec$[esp+204], ecx
	cmp	eax, ecx
	je	SHORT $LN32@drawImage
	mov	ecx, DWORD PTR [ebx+4]
	mov	edx, DWORD PTR [ebx+8]
	push	ecx
	mov	ecx, DWORD PTR _width$[ebp]
	push	edx
	mov	edx, DWORD PTR _str$[ebp]
	push	ecx
	push	edx
	mov	ecx, eax
	call	??0ImageStream@@QAE@PAVStream@@HHH@Z	; ImageStream::ImageStream
	mov	DWORD PTR $T174288[esp+196], eax
	jmp	SHORT $LN33@drawImage
$LN32@drawImage:
	mov	DWORD PTR $T174288[esp+196], ecx
$LN33@drawImage:

; 196  :     imgStr->reset();

	mov	ecx, DWORD PTR $T174288[esp+196]
	mov	DWORD PTR __$EHRec$[esp+204], -1
	call	?reset@ImageStream@@QAEXXZ		; ImageStream::reset

; 197  : 	img->numcomps = colorMap->getNumPixelComps();
; 198  :     // for each line...
; 199  : 	for (y = 0; y < height; ++y) 

	cmp	DWORD PTR _height$[ebp], 0
	mov	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR [esi+28], eax
	mov	DWORD PTR _y$[esp+196], 0
	jle	$LN10@drawImage
	npad	8
$LL12@drawImage:

; 200  : 	{
; 201  : 		// write the line
; 202  : 		p = imgStr->getLine();

	mov	ecx, DWORD PTR $T174288[esp+196]
	call	?getLine@ImageStream@@QAEPAEXZ		; ImageStream::getLine

; 203  : 		for (x = 0; x < width; ++x) 

	cmp	DWORD PTR _width$[ebp], 0
	mov	DWORD PTR _p$[esp+196], eax
	mov	DWORD PTR _x$[esp+196], 0
	jle	$LN11@drawImage
$LN9@drawImage:

; 204  : 		{
; 205  : 			colorMap->getRGB(p, &rgb);

	mov	edx, DWORD PTR _p$[esp+196]
	lea	ecx, DWORD PTR _rgb$[esp+196]
	push	ecx
	push	edx
	mov	ecx, ebx
	call	?getRGB@GfxImageColorMap@@QAEXPAEPAUGfxRGB@@@Z ; GfxImageColorMap::getRGB

; 206  : 			
; 207  : 			//Resize buffer preserving items
; 208  : 			if((count+colorMap->getNumPixelComps()+1)>bufSize){

	mov	eax, DWORD PTR [ebx+8]
	lea	ecx, DWORD PTR [eax+edi+1]
	mov	eax, DWORD PTR _bufSize$[esp+196]
	cmp	ecx, eax
	jle	SHORT $LN5@drawImage

; 209  : 				bufSize+=initBufSize;
; 210  : 				img->bytes=(byte *)realloc(img->bytes,bufSize+1);

	mov	edx, DWORD PTR [esi]
	add	eax, 16384				; 00004000H
	mov	DWORD PTR _bufSize$[esp+196], eax
	inc	eax
	push	eax
	push	edx
	call	DWORD PTR __imp__realloc
	add	esp, 8
	mov	DWORD PTR [esi], eax

; 211  : 				if(!img->bytes)

	test	eax, eax
	je	$LN80@drawImage
$LN5@drawImage:

; 213  : 			}
; 214  : 			//byte rgbc = RGB(colToByte(rgb.r),colToByte(rgb.g),colToByte(rgb.b));
; 215  : 			//img->bytes[count]= rgbc;
; 216  : 			//we need a bitmap of 24 bits
; 217  : 			img->bytes[count]  =(byte)colToByte(rgb.r);

	mov	eax, DWORD PTR _rgb$[esp+196]
	mov	ecx, DWORD PTR [esi]
	imul	eax, 255				; 000000ffH
	add	eax, 32768				; 00008000H
	sar	eax, 16					; 00000010H
	mov	BYTE PTR [edi+ecx], al

; 218  : 			
; 219  : 			if(img->numcomps==1){

	cmp	DWORD PTR [esi+28], 1
	jne	SHORT $LN4@drawImage

; 220  : 				GfxColor colr;
; 221  : 				colorMap->getColor(p,&colr);

	mov	eax, DWORD PTR _p$[esp+196]
	lea	edx, DWORD PTR _colr$10174[esp+196]
	push	edx
	push	eax
	mov	ecx, ebx
	call	?getColor@GfxImageColorMap@@QAEXPAEPAUGfxColor@@@Z ; GfxImageColorMap::getColor

; 222  : 				img->bytes[count]= RGB(colToByte(rgb.r),colToByte(rgb.g),colToByte(rgb.b));

	mov	ecx, DWORD PTR _rgb$[esp+196]
	mov	edx, DWORD PTR [esi]
	imul	ecx, 255				; 000000ffH
	add	ecx, 32768				; 00008000H
	sar	ecx, 16					; 00000010H
	mov	BYTE PTR [edi+edx], cl
$LN4@drawImage:

; 223  : 			}
; 224  : 			if(img->numcomps>=2)

	cmp	DWORD PTR [esi+28], 2
	jl	SHORT $LN3@drawImage

; 225  : 				img->bytes[count+1]=(byte)colToByte(rgb.g);

	mov	eax, DWORD PTR _rgb$[esp+200]
	mov	ecx, DWORD PTR [esi]
	imul	eax, 255				; 000000ffH
	add	eax, 32768				; 00008000H
	sar	eax, 16					; 00000010H
	mov	BYTE PTR [ecx+edi+1], al
$LN3@drawImage:

; 226  : 			if(img->numcomps>=3)

	cmp	DWORD PTR [esi+28], 3
	jl	SHORT $LN2@drawImage

; 227  : 				img->bytes[count+2]=(byte)colToByte(rgb.b);

	mov	edx, DWORD PTR _rgb$[esp+204]
	mov	eax, DWORD PTR [esi]
	imul	edx, 255				; 000000ffH
	add	edx, 32768				; 00008000H
	sar	edx, 16					; 00000010H
	mov	BYTE PTR [eax+edi+2], dl
$LN2@drawImage:

; 228  : 			if(img->numcomps==4)

	cmp	DWORD PTR [esi+28], 4
	jne	SHORT $LN1@drawImage

; 229  : 				img->bytes[count+3]=255;

	mov	ecx, DWORD PTR [esi]
	mov	BYTE PTR [ecx+edi+3], 255		; 000000ffH
$LN1@drawImage:

; 230  : 			
; 231  : 			p += colorMap->getNumPixelComps();

	mov	eax, DWORD PTR [ebx+8]
	add	DWORD PTR _p$[esp+196], eax

; 232  : 			count+=colorMap->getNumPixelComps();

	add	edi, eax
	mov	eax, DWORD PTR _x$[esp+196]
	inc	eax
	cmp	eax, DWORD PTR _width$[ebp]
	mov	DWORD PTR _x$[esp+196], eax
	jl	$LN9@drawImage
$LN11@drawImage:

; 197  : 	img->numcomps = colorMap->getNumPixelComps();
; 198  :     // for each line...
; 199  : 	for (y = 0; y < height; ++y) 

	mov	eax, DWORD PTR _y$[esp+196]
	inc	eax
	cmp	eax, DWORD PTR _height$[ebp]
	mov	DWORD PTR _y$[esp+196], eax
	jl	$LL12@drawImage
$LN10@drawImage:

; 233  : 		}
; 234  : 	}
; 235  : 	img->size=count;

	mov	DWORD PTR [esi+24], edi

; 236  : 	
; 237  :     delete imgStr;

	mov	edi, DWORD PTR $T174288[esp+196]
	test	edi, edi
	je	SHORT $LN34@drawImage
	mov	ecx, edi
	call	??1ImageStream@@QAE@XZ			; ImageStream::~ImageStream
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN34@drawImage:

; 238  :   }
; 239  :   _Images.Add(*img);

	mov	eax, DWORD PTR _this$[esp+196]
	push	esi
	add	eax, 104				; 00000068H
	call	?Add@?$DynArray@UImageInfo@@@@QAEXABUImageInfo@@@Z ; DynArray<ImageInfo>::Add

; 240  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+196]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
$LN80@drawImage:

; 212  : 					throw "Memory allocation failure!";

	push	OFFSET __TI2PAD
	lea	edx, DWORD PTR $T174292[esp+200]
	push	edx
	mov	DWORD PTR $T174292[esp+204], OFFSET ??_C@_0BL@BOIEBPCB@Memory?5allocation?5failure?$CB?$AA@
	call	__CxxThrowException@8
$LN95@drawImage:
$LN91@drawImage:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?drawImage@ImagesMemoryOutputDev@@UAEXPAVGfxState@@PAVObject@@PAVStream@@HHPAVGfxImageColorMap@@PAHH@Z$0:
	mov	eax, DWORD PTR $T174289[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?drawImage@ImagesMemoryOutputDev@@UAEXPAVGfxState@@PAVObject@@PAVStream@@HHPAVGfxImageColorMap@@PAHH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-180]
	mov	ecx, DWORD PTR [edx-184]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?drawImage@ImagesMemoryOutputDev@@UAEXPAVGfxState@@PAVObject@@PAVStream@@HHPAVGfxImageColorMap@@PAHH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?drawImage@ImagesMemoryOutputDev@@UAEXPAVGfxState@@PAVObject@@PAVStream@@HHPAVGfxImageColorMap@@PAHH@Z ENDP ; ImagesMemoryOutputDev::drawImage
END
