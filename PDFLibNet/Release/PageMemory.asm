; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\cygwin\home\uejima\PDFLibNet\libAFPDFLib\PageMemory.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat


EXTRN	__imp__CreateDIBSection@24:PROC
EXTRN	__imp__SetDIBits@28:PROC
EXTRN	__imp__BitBlt@36:PROC
EXTRN	__imp__CreateCompatibleDC@4:PROC
EXTRN	__imp__DeleteDC@4:PROC
EXTRN	__imp__StretchBlt@44:PROC
EXTRN	__imp__SetStretchBltMode@8:PROC
EXTRN	__imp__DeleteObject@4:PROC
	ORG $+3780
__bad_alloc_Message DD FLAT:??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
PUBLIC	?cvtDevTouser@PageMemory@@QAEXNNPAN0@Z		; PageMemory::cvtDevTouser
; Function compile flags: /Ogtpy
; File c:\cygwin\home\uejima\pdflibnet\libafpdflib\pagememory.cpp
;	COMDAT ?cvtDevTouser@PageMemory@@QAEXNNPAN0@Z
_TEXT	SEGMENT
_dx$ = 8						; size = 8
_dy$ = 16						; size = 8
?cvtDevTouser@PageMemory@@QAEXNNPAN0@Z PROC		; PageMemory::cvtDevTouser, COMDAT
; _this$ = eax
; _ux$ = ecx
; _uy$ = edx

; 194  :   *ux = defICTM[0] * dx + defICTM[2] * dy + defICTM[4];

	fld	QWORD PTR [eax+80]
	fld	QWORD PTR _dx$[esp-4]
	fmul	ST(1), ST(0)
	fld	QWORD PTR [eax+96]
	fld	QWORD PTR _dy$[esp-4]
	fmul	ST(1), ST(0)
	fxch	ST(3)
	faddp	ST(1), ST(0)
	fadd	QWORD PTR [eax+112]
	fstp	QWORD PTR [ecx]

; 195  :   *uy = defICTM[1] * dx + defICTM[3] * dy + defICTM[5];

	fmul	QWORD PTR [eax+88]
	fld	QWORD PTR [eax+104]
	fmulp	ST(2), ST(0)
	faddp	ST(1), ST(0)
	fadd	QWORD PTR [eax+120]
	fstp	QWORD PTR [edx]

; 196  : }

	ret	16					; 00000010H
?cvtDevTouser@PageMemory@@QAEXNNPAN0@Z ENDP		; PageMemory::cvtDevTouser
_TEXT	ENDS
PUBLIC	?cvtUserToDev@PageMemory@@QAEXNNPAH0@Z		; PageMemory::cvtUserToDev
; Function compile flags: /Ogtpy
;	COMDAT ?cvtUserToDev@PageMemory@@QAEXNNPAH0@Z
_TEXT	SEGMENT
_ux$ = 8						; size = 8
_uy$ = 16						; size = 8
_dx$ = 24						; size = 4
_dy$ = 28						; size = 4
?cvtUserToDev@PageMemory@@QAEXNNPAH0@Z PROC		; PageMemory::cvtUserToDev, COMDAT
; _this$ = esi

; 190  :   *dx = (int)(defCTM[0] * ux + defCTM[2] * uy + defCTM[4] + 0.5);

	fld	QWORD PTR [esi+32]
	fld	QWORD PTR _ux$[esp-4]
	fmul	ST(1), ST(0)
	fld	QWORD PTR [esi+48]
	fld	QWORD PTR _uy$[esp-4]
	fmul	ST(1), ST(0)
	fxch	ST(3)
	faddp	ST(1), ST(0)
	fadd	QWORD PTR [esi+64]
	fld	QWORD PTR __real@3fe0000000000000
	fadd	ST(1), ST(0)
	fxch	ST(1)
	call	__ftol2_sse
	mov	ecx, DWORD PTR _dx$[esp-4]
	mov	DWORD PTR [ecx], eax

; 191  :   *dy = (int)(defCTM[1] * ux + defCTM[3] * uy + defCTM[5] + 0.5);

	fld	QWORD PTR [esi+40]
	fmulp	ST(2), ST(0)
	fld	QWORD PTR [esi+56]
	fmulp	ST(3), ST(0)
	fxch	ST(1)
	faddp	ST(2), ST(0)
	fxch	ST(1)
	fadd	QWORD PTR [esi+72]
	faddp	ST(1), ST(0)
	call	__ftol2_sse
	mov	edx, DWORD PTR _dy$[esp-4]
	mov	DWORD PTR [edx], eax

; 192  : }

	ret	24					; 00000018H
?cvtUserToDev@PageMemory@@QAEXNNPAH0@Z ENDP		; PageMemory::cvtUserToDev
_TEXT	ENDS
PUBLIC	?Dispose@PageMemory@@QAEXXZ			; PageMemory::Dispose
; Function compile flags: /Ogtpy
;	COMDAT ?Dispose@PageMemory@@QAEXXZ
_TEXT	SEGMENT
?Dispose@PageMemory@@QAEXXZ PROC			; PageMemory::Dispose, COMDAT
; _this$ = esi

; 182  : 	if(_bitmap!=NULL){

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Dispose

; 183  : 		DeleteObject(_bitmap);

	push	eax
	call	DWORD PTR __imp__DeleteObject@4
$LN4@Dispose:

; 184  : 	}
; 185  : 	_bitmap=NULL;
; 186  : 	_bits=NULL;

	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0

; 187  : }

	ret	0
?Dispose@PageMemory@@QAEXXZ ENDP			; PageMemory::Dispose
_TEXT	ENDS
PUBLIC	?GetDIBits@PageMemory@@QAEPAXXZ			; PageMemory::GetDIBits
; Function compile flags: /Ogtpy
;	COMDAT ?GetDIBits@PageMemory@@QAEPAXXZ
_TEXT	SEGMENT
?GetDIBits@PageMemory@@QAEPAXXZ PROC			; PageMemory::GetDIBits, COMDAT
; _this$ = eax

; 177  : 	return _bits;

	mov	eax, DWORD PTR [eax]

; 178  : }

	ret	0
?GetDIBits@PageMemory@@QAEPAXXZ ENDP			; PageMemory::GetDIBits
_TEXT	ENDS
PUBLIC	?Draw@PageMemory@@QAEHPAUHBITMAP__@@HHHHHH@Z	; PageMemory::Draw
; Function compile flags: /Ogtpy
;	COMDAT ?Draw@PageMemory@@QAEHPAUHBITMAP__@@HHHHHH@Z
_TEXT	SEGMENT
?Draw@PageMemory@@QAEHPAUHBITMAP__@@HHHHHH@Z PROC	; PageMemory::Draw, COMDAT

; 172  : 	return 0;

	xor	eax, eax

; 173  : }

	ret	0
?Draw@PageMemory@@QAEHPAUHBITMAP__@@HHHHHH@Z ENDP	; PageMemory::Draw
_TEXT	ENDS
PUBLIC	?Resize@PageMemory@@QAEXHHN@Z			; PageMemory::Resize
; Function compile flags: /Ogtpy
;	COMDAT ?Resize@PageMemory@@QAEXHHN@Z
_TEXT	SEGMENT
tv162 = -4						; size = 4
_width$ = 8						; size = 4
_height$ = 12						; size = 4
_renderDPI$ = 16					; size = 8
?Resize@PageMemory@@QAEXHHN@Z PROC			; PageMemory::Resize, COMDAT
; _this$ = eax

; 79   : {

	push	ecx

; 80   : 	if(Width!=width || Height!=height){

	mov	ecx, DWORD PTR [eax+128]
	mov	DWORD PTR tv162[esp+4], ecx
	cmp	ecx, DWORD PTR _width$[esp]
	jne	SHORT $LN1@Resize
	mov	ecx, DWORD PTR [eax+132]
	cmp	ecx, DWORD PTR _height$[esp]
	je	SHORT $LN2@Resize
$LN1@Resize:

; 81   : /*		
; 82   : 		HBITMAP hbmNew = ScaleBitmap(_bitmap,width,height);
; 83   : 	
; 84   : 		if(_bitmap!=NULL){
; 85   : 			DeleteObject(_bitmap);
; 86   : 			_bitmap=NULL;
; 87   : 		}
; 88   : 		_bitmap=hbmNew;
; 89   : 		
; 90   : 		Width=width;
; 91   : 		Height=height;	
; 92   : */
; 93   : 		_factorW = (float)width/((float)Width);

	fild	DWORD PTR _width$[esp]
	fidiv	DWORD PTR tv162[esp+4]
	fstp	DWORD PTR [eax+8]

; 94   : 		_factorH = (float)height/((float)Height);

	fild	DWORD PTR _height$[esp]
	fidiv	DWORD PTR [eax+132]
	fstp	DWORD PTR [eax+12]

; 95   : 		_renderDPI = renderDPI;

	fld	QWORD PTR _renderDPI$[esp]
	fstp	QWORD PTR [eax+16]
$LN2@Resize:

; 96   : 	}
; 97   : }

	pop	ecx
	ret	16					; 00000010H
?Resize@PageMemory@@QAEXHHN@Z ENDP			; PageMemory::Resize
_TEXT	ENDS
PUBLIC	?SetDimensions@PageMemory@@QAEXHHN@Z		; PageMemory::SetDimensions
; Function compile flags: /Ogtpy
;	COMDAT ?SetDimensions@PageMemory@@QAEXHHN@Z
_TEXT	SEGMENT
_renderDPI$ = 8						; size = 8
?SetDimensions@PageMemory@@QAEXHHN@Z PROC		; PageMemory::SetDimensions, COMDAT
; _this$ = eax
; _width$ = ecx
; _height$ = edx

; 70   : 	//if(this->_bitmap != NULL )
; 71   : //		Resize(width,height);
; 72   : 	_factorW=1;

	fld1

; 73   : 	_factorH=1;
; 74   : 	_renderDPI = renderDPI;
; 75   : 	Width=width;

	mov	DWORD PTR [eax+128], ecx
	fst	DWORD PTR [eax+8]

; 76   : 	Height=height;	

	mov	DWORD PTR [eax+132], edx
	fstp	DWORD PTR [eax+12]
	fld	QWORD PTR _renderDPI$[esp-4]
	fstp	QWORD PTR [eax+16]

; 77   : }

	ret	8
?SetDimensions@PageMemory@@QAEXHHN@Z ENDP		; PageMemory::SetDimensions
_TEXT	ENDS
PUBLIC	?GetBitmapInfo@PageMemory@@AAE?AUtagBITMAPINFO@@XZ ; PageMemory::GetBitmapInfo
; Function compile flags: /Ogtpy
;	COMDAT ?GetBitmapInfo@PageMemory@@AAE?AUtagBITMAPINFO@@XZ
_TEXT	SEGMENT
?GetBitmapInfo@PageMemory@@AAE?AUtagBITMAPINFO@@XZ PROC	; PageMemory::GetBitmapInfo, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 41   : {

	push	ebx

; 42   : 	BITMAPINFO bmi;
; 43   : 	ZeroMemory(&bmi,sizeof(bmi));

	push	44					; 0000002cH
	xor	ebx, ebx
	push	ebx
	push	esi
	call	_memset

; 44   : 	bmi.bmiHeader.biSize=sizeof(BITMAPINFOHEADER);
; 45   : 	bmi.bmiHeader.biWidth=Width;

	mov	eax, DWORD PTR [edi+128]

; 46   : 	//By default bitmaps are bottom up images which means 1st scanline is bottom when and last is top one.
; 47   : 	bmi.bmiHeader.biHeight=-Height;

	mov	ecx, DWORD PTR [edi+132]
	mov	DWORD PTR [esi+4], eax

; 48   : 	bmi.bmiHeader.biPlanes=1;
; 49   : 	bmi.bmiHeader.biBitCount=24;

	mov	eax, 24					; 00000018H
	add	esp, 12					; 0000000cH
	neg	ecx
	mov	edx, 1
	mov	WORD PTR [esi+14], ax

; 50   : 	bmi.bmiHeader.biCompression=BI_RGB;

	mov	DWORD PTR [esi+16], ebx

; 51   : 
; 52   : 	bmi.bmiColors[0].rgbBlue = 0;

	mov	BYTE PTR [esi+40], bl

; 53   : 	bmi.bmiColors[0].rgbGreen = 0;

	mov	BYTE PTR [esi+41], bl

; 54   : 	bmi.bmiColors[0].rgbRed = 0;

	mov	BYTE PTR [esi+42], bl

; 55   : 	bmi.bmiColors[0].rgbReserved = 0;

	mov	BYTE PTR [esi+43], bl
	mov	DWORD PTR [esi], 40			; 00000028H
	mov	DWORD PTR [esi+8], ecx
	mov	WORD PTR [esi+12], dx

; 56   : 
; 57   : 	return bmi;

	mov	eax, esi
	pop	ebx

; 58   : }

	ret	0
?GetBitmapInfo@PageMemory@@AAE?AUtagBITMAPINFO@@XZ ENDP	; PageMemory::GetBitmapInfo
_TEXT	ENDS
PUBLIC	?Create@PageMemory@@QAEHPAUHDC__@@HHNPAN1@Z	; PageMemory::Create
; Function compile flags: /Ogtpy
;	COMDAT ?Create@PageMemory@@QAEHPAUHDC__@@HHNPAN1@Z
_TEXT	SEGMENT
_bmi$ = -44						; size = 44
_clientDC$ = 8						; size = 4
_width$ = 12						; size = 4
_height$ = 16						; size = 4
_renderDPI$ = 20					; size = 8
?Create@PageMemory@@QAEHPAUHDC__@@HHNPAN1@Z PROC	; PageMemory::Create, COMDAT
; _this$ = esi
; _defcmt$ = ebx
; _deficmt$ = edi

; 20   : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H

; 21   : 	//Delete object
; 22   : 	Dispose();

	mov	eax, DWORD PTR [esi+4]
	sub	esp, 48					; 00000030H
	test	eax, eax
	je	SHORT $LN7@Create
	push	eax
	call	DWORD PTR __imp__DeleteObject@4
$LN7@Create:

; 23   : 	Width=width;

	mov	eax, DWORD PTR _width$[ebp]

; 24   : 	Height=height;

	mov	ecx, DWORD PTR _height$[ebp]
	mov	DWORD PTR [esi+128], eax
	mov	DWORD PTR [esi+132], ecx
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi], 0

; 25   : 	for(int i=0; i<6; ++i){
; 26   : 		defCTM[i] = defcmt[i];

	fld	QWORD PTR [ebx]
	fstp	QWORD PTR [esi+32]

; 27   : 		defICTM[i] =deficmt[i];
; 28   : 	}
; 29   : 	_renderDPI = renderDPI;
; 30   : 	BITMAPINFO bmi=GetBitmapInfo();

	push	44					; 0000002cH
	fld	QWORD PTR [edi]
	lea	edx, DWORD PTR _bmi$[esp+52]
	fstp	QWORD PTR [esi+80]
	push	0
	fld	QWORD PTR [ebx+8]
	push	edx
	fstp	QWORD PTR [esi+40]
	fld	QWORD PTR [edi+8]
	fstp	QWORD PTR [esi+88]
	fld	QWORD PTR [ebx+16]
	fstp	QWORD PTR [esi+48]
	fld	QWORD PTR [edi+16]
	fstp	QWORD PTR [esi+96]
	fld	QWORD PTR [ebx+24]
	fstp	QWORD PTR [esi+56]
	fld	QWORD PTR [edi+24]
	fstp	QWORD PTR [esi+104]
	fld	QWORD PTR [ebx+32]
	fstp	QWORD PTR [esi+64]
	fld	QWORD PTR [edi+32]
	fstp	QWORD PTR [esi+112]
	fld	QWORD PTR [ebx+40]
	fstp	QWORD PTR [esi+72]
	fld	QWORD PTR [edi+40]
	fstp	QWORD PTR [esi+120]
	fld	QWORD PTR _renderDPI$[ebp]
	fstp	QWORD PTR [esi+16]
	call	_memset
	mov	eax, DWORD PTR [esi+128]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _bmi$[esp+52], eax
	mov	eax, DWORD PTR [esi+132]

; 31   : 	bmi.bmiHeader.biHeight=-bmi.bmiHeader.biHeight;
; 32   : 	if((_bitmap = CreateDIBSection(clientDC, &bmi, DIB_RGB_COLORS, &_bits,NULL,0))==NULL){

	push	0
	push	0
	neg	eax
	neg	eax
	push	esi
	mov	ecx, 1
	mov	DWORD PTR _bmi$[esp+68], eax
	push	0
	lea	eax, DWORD PTR _bmi$[esp+64]
	mov	WORD PTR _bmi$[esp+76], cx
	mov	ecx, DWORD PTR _clientDC$[ebp]
	push	eax
	mov	edx, 24					; 00000018H
	push	ecx
	mov	DWORD PTR _bmi$[esp+72], 40		; 00000028H
	mov	WORD PTR _bmi$[esp+86], dx
	mov	DWORD PTR _bmi$[esp+88], 0
	mov	BYTE PTR _bmi$[esp+112], 0
	mov	BYTE PTR _bmi$[esp+113], 0
	mov	BYTE PTR _bmi$[esp+114], 0
	mov	BYTE PTR _bmi$[esp+115], 0
	call	DWORD PTR __imp__CreateDIBSection@24
	xor	edx, edx
	test	eax, eax
	setne	dl
	mov	DWORD PTR [esi+4], eax
	mov	eax, edx

; 33   : //		ASSERT(1==0);
; 34   : 		return FALSE;
; 35   : 	}
; 36   : 	
; 37   : 	return TRUE;
; 38   : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?Create@PageMemory@@QAEHPAUHDC__@@HHNPAN1@Z ENDP	; PageMemory::Create
_TEXT	ENDS
PUBLIC	??1PageMemory@@QAE@XZ				; PageMemory::~PageMemory
; Function compile flags: /Ogtpy
;	COMDAT ??1PageMemory@@QAE@XZ
_TEXT	SEGMENT
??1PageMemory@@QAE@XZ PROC				; PageMemory::~PageMemory, COMDAT
; _this$ = esi

; 16   : 	Dispose();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@PageMemory
	push	eax
	call	DWORD PTR __imp__DeleteObject@4
$LN6@PageMemory:
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0

; 17   : }

	ret	0
??1PageMemory@@QAE@XZ ENDP				; PageMemory::~PageMemory
_TEXT	ENDS
PUBLIC	??0PageMemory@@QAE@XZ				; PageMemory::PageMemory
; Function compile flags: /Ogtpy
;	COMDAT ??0PageMemory@@QAE@XZ
_TEXT	SEGMENT
??0PageMemory@@QAE@XZ PROC				; PageMemory::PageMemory, COMDAT
; _this$ = eax

; 9    : {

	fld1
	xor	ecx, ecx
	fst	DWORD PTR [eax+8]
	mov	DWORD PTR [eax], ecx
	fstp	DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], ecx
	fldz

; 10   : 	Width=0;

	mov	DWORD PTR [eax+128], ecx
	fstp	QWORD PTR [eax+16]

; 11   : 	Height=0;

	mov	DWORD PTR [eax+132], ecx

; 12   : }

	ret	0
??0PageMemory@@QAE@XZ ENDP				; PageMemory::PageMemory
PUBLIC	?Draw@PageMemory@@QAEHPAUHDC__@@HHHHHH@Z	; PageMemory::Draw
; Function compile flags: /Ogtpy
;	COMDAT ?Draw@PageMemory@@QAEHPAUHDC__@@HHHHHH@Z
_TEXT	SEGMENT
_h$81026 = -12						; size = 4
_w$81025 = -8						; size = 4
_pOld$ = -4						; size = 4
_xSrc$ = 8						; size = 4
_ySrc$ = 12						; size = 4
tv339 = 16						; size = 4
tv332 = 16						; size = 4
_width$ = 16						; size = 4
_height$ = 20						; size = 4
_xDest$ = 24						; size = 4
_yDest$ = 28						; size = 4
?Draw@PageMemory@@QAEHPAUHDC__@@HHHHHH@Z PROC		; PageMemory::Draw, COMDAT
; _this$ = esi
; _hdc$ = ebx

; 101  : {

	sub	esp, 12					; 0000000cH
	push	ebp
	mov	ebp, DWORD PTR _width$[esp+12]
	push	edi

; 102  : 	BITMAPINFO bmi=GetBitmapInfo();
; 103  : 	//********START DIB
; 104  : 	//HDC dc;
; 105  : 	HDC mdc;
; 106  : 	//CDC tmpDC;
; 107  : 	//HBitmap bmpTmp;
; 108  : 	//dc.Attach(hdc);
; 109  : 	//mdc.CreateCompatibleDC(&dc);
; 110  : 	mdc = CreateCompatibleDC(hdc);

	push	ebx
	call	DWORD PTR __imp__CreateCompatibleDC@4
	mov	edi, eax

; 111  : 	HGDIOBJ pOld = SelectObject(mdc,_bitmap);

	mov	eax, DWORD PTR [esi+4]
	push	eax
	push	edi
	call	DWORD PTR __imp__SelectObject@8

; 112  : 	if(_factorW!=1 || _factorH !=1)

	fld1
	fcom	DWORD PTR [esi+8]
	mov	DWORD PTR _pOld$[esp+20], eax
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN13@Draw
	fcomp	DWORD PTR [esi+12]
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN4@Draw

; 152  : 
; 153  : 	}else{
; 154  : 		
; 155  : 
; 156  : 		BitBlt(hdc,xDest,yDest,width,height,mdc,xSrc,ySrc,SRCCOPY);		

	mov	ecx, DWORD PTR _ySrc$[esp+16]
	mov	edx, DWORD PTR _xSrc$[esp+16]
	mov	eax, DWORD PTR _height$[esp+16]
	push	13369376				; 00cc0020H
	push	ecx
	mov	ecx, DWORD PTR _yDest$[esp+24]
	push	edx
	mov	edx, DWORD PTR _xDest$[esp+28]
	push	edi
	push	eax
	push	ebp
	push	ecx
	push	edx
	push	ebx
	call	DWORD PTR __imp__BitBlt@36
	jmp	$LN1@Draw
$LN13@Draw:

; 112  : 	if(_factorW!=1 || _factorH !=1)

	fstp	ST(0)
$LN4@Draw:

; 113  : 	{
; 114  : 		BITMAPINFO bih = GetBitmapInfo();
; 115  : 		bih.bmiHeader.biHeight = -bih.bmiHeader.biHeight ; //Top-Down
; 116  : 		SetStretchBltMode(hdc,COLORONCOLOR );

	push	3
	push	ebx
	call	DWORD PTR __imp__SetStretchBltMode@8

; 117  : 		/*
; 118  : 		StretchDIBits(hdc,
; 119  : 			xDest*_factorW,
; 120  : 			yDest*_factorH,		//Location 
; 121  : 			width*_factorW,		//Width dest
; 122  : 			height*_factorH,	//Height dest
; 123  : 			xSrc,
; 124  : 			-ySrc,			//Source position
; 125  : 			width,
; 126  : 			height,		//Source Size
; 127  : 			_bits,				//DIB Bits
; 128  : 			&bih,				//Bitmap Info Header
; 129  : 			DIB_RGB_COLORS,		//RGB Data
; 130  : 			SRCCOPY );			//Copy the source
; 131  : 		*/
; 132  : 		int w=width;
; 133  : 		int h=height;
; 134  : 		//ZoomOut
; 135  : 		if(width*_factorW<w || height*_factorH<h)

	fild	DWORD PTR _width$[esp+16]
	mov	ecx, DWORD PTR _height$[esp+16]
	mov	DWORD PTR _w$81025[esp+20], ebp
	fstp	DWORD PTR tv332[esp+16]
	mov	DWORD PTR _h$81026[esp+20], ecx
	fld	DWORD PTR [esi+8]
	fld	DWORD PTR tv332[esp+16]
	fld	ST(0)
	fmulp	ST(2), ST(0)
	fcom	ST(1)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 65					; 00000041H
	je	SHORT $LN2@Draw
	fild	DWORD PTR _height$[esp+16]
	fstp	DWORD PTR tv339[esp+16]
	fld	DWORD PTR [esi+12]
	fld	DWORD PTR tv339[esp+16]
	fld	ST(0)
	fmulp	ST(2), ST(0)
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN18@Draw
$LN2@Draw:

; 136  : 		{
; 137  : 			w*=_factorW;

	fmul	DWORD PTR [esi+8]
	call	__ftol2_sse

; 138  : 			h*=_factorH;

	fild	DWORD PTR _height$[esp+16]
	mov	ebp, eax
	mov	DWORD PTR _w$81025[esp+20], ebp
	fmul	DWORD PTR [esi+12]
	call	__ftol2_sse
	mov	ecx, eax
	mov	DWORD PTR _h$81026[esp+20], ecx
	jmp	SHORT $LN3@Draw
$LN18@Draw:
	fstp	ST(0)
$LN3@Draw:

; 139  : 		}
; 140  : 		
; 141  : 		StretchBlt(hdc,
; 142  : 			xDest,
; 143  : 			yDest,
; 144  : 			w*_factorW,
; 145  : 			h*_factorH ,
; 146  : 			mdc,
; 147  : 			xSrc/_factorW,
; 148  : 			ySrc/_factorH,
; 149  : 			w,
; 150  : 			h,
; 151  : 			SRCCOPY);

	fild	DWORD PTR _ySrc$[esp+16]
	push	13369376				; 00cc0020H
	push	ecx
	push	ebp
	fdiv	DWORD PTR [esi+12]
	call	__ftol2_sse
	fild	DWORD PTR _xSrc$[esp+28]
	push	eax
	fdiv	DWORD PTR [esi+8]
	call	__ftol2_sse
	fild	DWORD PTR _h$81026[esp+36]
	push	eax
	push	edi
	fmul	DWORD PTR [esi+12]
	call	__ftol2_sse
	fild	DWORD PTR _w$81025[esp+44]
	push	eax
	fmul	DWORD PTR [esi+8]
	call	__ftol2_sse
	mov	ecx, DWORD PTR _xDest$[esp+44]
	push	eax
	mov	eax, DWORD PTR _yDest$[esp+48]
	push	eax
	push	ecx
	push	ebx
	call	DWORD PTR __imp__StretchBlt@44
$LN1@Draw:

; 157  : 
; 158  : 		
; 159  : 	}
; 160  : 	SelectObject(mdc,pOld);

	mov	edx, DWORD PTR _pOld$[esp+20]
	push	edx
	push	edi
	call	DWORD PTR __imp__SelectObject@8

; 161  : 		DeleteDC(mdc);

	push	edi
	call	DWORD PTR __imp__DeleteDC@4
	pop	edi

; 162  : 		//dc.Detach();
; 163  : 
; 164  : 
; 165  : 
; 166  : 	//********END DIB
; 167  : 	return TRUE;

	mov	eax, 1
	pop	ebp

; 168  : }

	add	esp, 12					; 0000000cH
	ret	24					; 00000018H
?Draw@PageMemory@@QAEHPAUHDC__@@HHHHHH@Z ENDP		; PageMemory::Draw
_TEXT	ENDS
PUBLIC	?SetDIBits@PageMemory@@QAEHPAUHDC__@@PBX@Z	; PageMemory::SetDIBits
; Function compile flags: /Ogtpy
;	COMDAT ?SetDIBits@PageMemory@@QAEHPAUHDC__@@PBX@Z
_TEXT	SEGMENT
_bmi$ = -44						; size = 44
_clientDC$ = 8						; size = 4
_lpBits$ = 12						; size = 4
?SetDIBits@PageMemory@@QAEHPAUHDC__@@PBX@Z PROC		; PageMemory::SetDIBits, COMDAT
; _this$ = esi

; 61   : {

	sub	esp, 44					; 0000002cH
	push	ebx

; 62   : 	BITMAPINFO bmi=GetBitmapInfo();

	push	44					; 0000002cH
	xor	ebx, ebx
	lea	eax, DWORD PTR _bmi$[esp+52]
	push	ebx
	push	eax
	call	_memset
	mov	eax, DWORD PTR [esi+132]
	mov	ecx, DWORD PTR [esi+128]
	add	esp, 12					; 0000000cH
	mov	edx, eax
	mov	DWORD PTR _bmi$[esp+52], ecx
	neg	edx

; 63   : 	::SetDIBits(clientDC,_bitmap,0,Height,lpBits,&bmi,DIB_RGB_COLORS);

	push	ebx
	mov	DWORD PTR _bmi$[esp+60], edx
	mov	ecx, 1
	mov	WORD PTR _bmi$[esp+64], cx
	mov	edx, 24					; 00000018H
	lea	ecx, DWORD PTR _bmi$[esp+52]
	push	ecx
	mov	ecx, DWORD PTR _clientDC$[esp+52]
	mov	WORD PTR _bmi$[esp+70], dx
	mov	edx, DWORD PTR _lpBits$[esp+52]
	push	edx
	push	eax
	mov	eax, DWORD PTR [esi+4]
	push	ebx
	push	eax
	push	ecx
	mov	DWORD PTR _bmi$[esp+76], 40		; 00000028H
	mov	DWORD PTR _bmi$[esp+92], ebx
	mov	BYTE PTR _bmi$[esp+116], bl
	mov	BYTE PTR _bmi$[esp+117], bl
	mov	BYTE PTR _bmi$[esp+118], bl
	mov	BYTE PTR _bmi$[esp+119], bl
	call	DWORD PTR __imp__SetDIBits@28

; 64   : 
; 65   : 	return TRUE;

	lea	eax, DWORD PTR [ebx+1]
	pop	ebx

; 66   : }

	add	esp, 44					; 0000002cH
	ret	8
?SetDIBits@PageMemory@@QAEHPAUHDC__@@PBX@Z ENDP		; PageMemory::SetDIBits
END
