; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\cygwin\home\uejima\PDFLibNet\libAFPDFLib\mupdfEngine.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat


PUBLIC	??_C@_0BO@PDJELKHG@XRef?5Read?5error?0?5invalid?5file?$AA@ ; `string'
PUBLIC	??_C@_0CO@NNAHHPIL@XRef?5Read?5error?0?5corrupt?5data?4?5C@ ; `string'
PUBLIC	??_C@_0BD@GNDEIHJH@XRef?5Decrypt?5error?$AA@	; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_0CG@GKJDKIFA@File?5needs?5password?0?5invalid?5pas@ ; `string'
PUBLIC	??_C@_0BO@KNACDEIG@Can?5not?5create?5mupdf?5renderer?$AA@ ; `string'
PUBLIC	??_C@_0DA@NOMLDOFL@Can?5not?5render?5page?0?5unknown?5pro@ ; `string'
;	COMDAT ??_C@_0DA@NOMLDOFL@Can?5not?5render?5page?0?5unknown?5pro@
CONST	SEGMENT
??_C@_0DA@NOMLDOFL@Can?5not?5render?5page?0?5unknown?5pro@ DB 'Can not re'
	DB	'nder page, unknown problem with mupdf', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@KNACDEIG@Can?5not?5create?5mupdf?5renderer?$AA@
CONST	SEGMENT
??_C@_0BO@KNACDEIG@Can?5not?5create?5mupdf?5renderer?$AA@ DB 'Can not cre'
	DB	'ate mupdf renderer', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@GKJDKIFA@File?5needs?5password?0?5invalid?5pas@
CONST	SEGMENT
??_C@_0CG@GKJDKIFA@File?5needs?5password?0?5invalid?5pas@ DB 'File needs '
	DB	'password, invalid password', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GNDEIHJH@XRef?5Decrypt?5error?$AA@
CONST	SEGMENT
??_C@_0BD@GNDEIHJH@XRef?5Decrypt?5error?$AA@ DB 'XRef Decrypt error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@NNAHHPIL@XRef?5Read?5error?0?5corrupt?5data?4?5C@
CONST	SEGMENT
??_C@_0CO@NNAHHPIL@XRef?5Read?5error?0?5corrupt?5data?4?5C@ DB 'XRef Read'
	DB	' error, corrupt data. Can not repair', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@PDJELKHG@XRef?5Read?5error?0?5invalid?5file?$AA@
CONST	SEGMENT
??_C@_0BO@PDJELKHG@XRef?5Read?5error?0?5invalid?5file?$AA@ DB 'XRef Read '
	DB	'error, invalid file', 00H			; `string'
	ORG $+3780
__bad_alloc_Message DD FLAT:??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
PUBLIC	?viewctm@mupdfEngine@@QAE?AUfz_matrix_s@@PAUpdf_page_s@@MH@Z ; mupdfEngine::viewctm
; Function compile flags: /Ogtpy
; File c:\cygwin\home\uejima\pdflibnet\libafpdflib\mupdfengine.cpp
;	COMDAT ?viewctm@mupdfEngine@@QAE?AUfz_matrix_s@@PAUpdf_page_s@@MH@Z
_TEXT	SEGMENT
$T159000 = -52						; size = 24
$T158996 = -52						; size = 24
$T158991 = -52						; size = 24
$T158988 = -52						; size = 24
$T158999 = -28						; size = 24
$T158995 = -28						; size = 24
$T158992 = -28						; size = 24
_zoom$ = 8						; size = 4
_rotate$ = 12						; size = 4
?viewctm@mupdfEngine@@QAE?AUfz_matrix_s@@PAUpdf_page_s@@MH@Z PROC ; mupdfEngine::viewctm, COMDAT
; ___$ReturnUdt$ = esi
; _page$ = edi

; 173  :     fz_matrix ctm;
; 174  :     ctm = fz_identity();

	lea	eax, DWORD PTR $T158988[esp]
	sub	esp, 52					; 00000034H
	push	eax
	call	_fz_identity

; 175  :     //ctm = fz_concat(ctm, fz_translate(0, -page->mediabox.y1));
; 176  :     ctm = fz_concat(ctm, fz_translate(-page->mediabox.x0, -page->mediabox.y1));

	fld	DWORD PTR [edi+12]
	mov	ecx, DWORD PTR [eax]
	fchs
	mov	edx, DWORD PTR [eax+4]
	fstp	DWORD PTR [esp]
	fld	DWORD PTR [edi]
	mov	DWORD PTR [esi], ecx
	mov	ecx, DWORD PTR [eax+8]
	fchs
	mov	DWORD PTR [esi+4], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [esi+8], ecx
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [esi+12], edx
	mov	edx, DWORD PTR [eax+20]
	push	ecx
	lea	eax, DWORD PTR $T158991[esp+60]
	fstp	DWORD PTR [esp]
	mov	DWORD PTR [esi+16], ecx
	push	eax
	mov	DWORD PTR [esi+20], edx
	call	_fz_translate
	mov	edx, DWORD PTR [eax]
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	edx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR [ecx+16], edx
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+20], eax
	mov	ecx, DWORD PTR [esi]
	sub	esp, 24					; 00000018H
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [esi+12]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [esi+20]
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax+20], edx
	lea	eax, DWORD PTR $T158992[esp+100]
	push	eax
	call	_fz_concat

; 177  :     ctm = fz_concat(ctm, fz_scale(zoom, -zoom));

	fld	DWORD PTR _zoom$[esp+100]
	mov	ecx, DWORD PTR [eax]
	fld	ST(0)
	mov	edx, DWORD PTR [eax+4]
	fchs
	mov	DWORD PTR [esi], ecx
	fstp	DWORD PTR [esp+48]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [esi+4], edx
	fstp	DWORD PTR [esp+44]
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [esi+8], ecx
	mov	ecx, DWORD PTR [eax+16]
	add	esp, 44					; 0000002cH
	mov	DWORD PTR [esi+12], edx
	mov	edx, DWORD PTR [eax+20]
	lea	eax, DWORD PTR $T158995[esp+60]
	mov	DWORD PTR [esi+16], ecx
	push	eax
	mov	DWORD PTR [esi+20], edx
	call	_fz_scale
	mov	edx, DWORD PTR [eax]
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	edx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR [ecx+16], edx
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+20], eax
	mov	ecx, DWORD PTR [esi]
	sub	esp, 24					; 00000018H
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [esi+12]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [esi+20]
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax+20], edx
	lea	eax, DWORD PTR $T158996[esp+100]
	push	eax
	call	_fz_concat
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [esi], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [esi+4], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [esi+8], ecx
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [esi+12], edx
	mov	edx, DWORD PTR [eax+20]

; 178  :     rotate += page->rotate;

	mov	eax, DWORD PTR [edi+16]
	add	esp, 52					; 00000034H
	add	DWORD PTR _rotate$[esp+48], eax
	mov	DWORD PTR [esi+16], ecx
	mov	DWORD PTR [esi+20], edx

; 179  :     if (rotate != 0)

	je	$LN4@viewctm

; 180  :         ctm = fz_concat(ctm, fz_rotate(rotate));

	fild	DWORD PTR _rotate$[esp+48]
	push	ecx
	lea	ecx, DWORD PTR $T158999[esp+56]
	fstp	DWORD PTR [esp]
	push	ecx
	call	_fz_rotate
	mov	edx, DWORD PTR [eax]
	sub	esp, 16					; 00000010H
	mov	ecx, esp
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	edx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR [ecx+16], edx
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+20], eax
	mov	ecx, DWORD PTR [esi]
	sub	esp, 24					; 00000018H
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [esi+12]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [esi+20]
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax+20], edx
	lea	eax, DWORD PTR $T159000[esp+100]
	push	eax
	call	_fz_concat
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [esi], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [esi+4], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [esi+8], ecx
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [esi+12], edx
	mov	edx, DWORD PTR [eax+20]
	mov	DWORD PTR [esi+16], ecx
	add	esp, 52					; 00000034H
	mov	DWORD PTR [esi+20], edx
$LN4@viewctm:

; 181  :     return ctm;

	mov	eax, esi

; 182  : }

	add	esp, 52					; 00000034H
	ret	8
?viewctm@mupdfEngine@@QAE?AUfz_matrix_s@@PAUpdf_page_s@@MH@Z ENDP ; mupdfEngine::viewctm
_TEXT	ENDS
PUBLIC	??0mupdfEngine@@QAE@XZ				; mupdfEngine::mupdfEngine
; Function compile flags: /Ogtpy
;	COMDAT ??0mupdfEngine@@QAE@XZ
_TEXT	SEGMENT
??0mupdfEngine@@QAE@XZ PROC				; mupdfEngine::mupdfEngine, COMDAT
; _this$ = eax

; 43   : {

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 44   : }

	ret	0
??0mupdfEngine@@QAE@XZ ENDP				; mupdfEngine::mupdfEngine
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?ConvertPixmapForWindows@@YAXPAUfz_pixmap_s@@@Z
_TEXT	SEGMENT
tv285 = -12						; size = 4
tv337 = -8						; size = 4
_bmpdata$ = -4						; size = 4
_image$ = 8						; size = 4
?ConvertPixmapForWindows@@YAXPAUfz_pixmap_s@@@Z PROC	; ConvertPixmapForWindows, COMDAT

; 9    : {

	sub	esp, 12					; 0000000cH

; 10   :    int bmpstride = ((image->w * 3 + 3) / 4) * 4;

	mov	ecx, DWORD PTR _image$[esp+8]
	push	ebx
	push	ebp
	push	esi

; 11   :    int imageh = image->h;

	mov	esi, DWORD PTR [ecx+12]
	push	edi
	mov	edi, DWORD PTR [ecx+8]
	lea	eax, DWORD PTR [edi+edi*2+3]
	cdq
	and	edx, 3
	add	eax, edx
	mov	ebp, eax
	sar	ebp, 2
	add	ebp, ebp
	add	ebp, ebp

; 12   :    int imagew = image->w;
; 13   :    unsigned char *bmpdata = (unsigned char*)fz_malloc(image->h * bmpstride);

	mov	eax, esi
	imul	eax, ebp
	push	eax
	call	_fz_malloc
	mov	ebx, eax
	add	esp, 4
	mov	DWORD PTR _bmpdata$[esp+28], ebx

; 14   :    if (!bmpdata)

	test	ebx, ebx
	je	SHORT $LN8@ConvertPix

; 15   :        return;
; 16   : 
; 17   :    unsigned char *p = bmpdata;
; 18   :    unsigned char *s = image->samples;

	mov	ecx, DWORD PTR _image$[esp+24]
	mov	eax, DWORD PTR [ecx+20]

; 19   :    for (int y = 0; y < imageh; y++)

	test	esi, esi
	jle	SHORT $LN4@ConvertPix
	lea	ecx, DWORD PTR [eax+2]
	lea	edx, DWORD PTR [ebx+2]
	mov	DWORD PTR tv285[esp+28], ecx
	mov	DWORD PTR tv337[esp+28], esi
$LL6@ConvertPix:

; 20   :    {
; 21   :        unsigned char *pl = p;
; 22   :        unsigned char *sl = s;
; 23   :        for (int x = 0; x < imagew; x++)

	test	edi, edi
	jle	SHORT $LN1@ConvertPix
	mov	eax, edx
	mov	esi, edi
	npad	3
$LL3@ConvertPix:

; 24   :        {
; 25   :            pl[0] = sl[3];

	movzx	ebx, BYTE PTR [ecx+1]
	mov	BYTE PTR [eax-2], bl

; 26   :            pl[1] = sl[2];

	movzx	ebx, BYTE PTR [ecx]
	mov	BYTE PTR [eax-1], bl

; 27   :            pl[2] = sl[1];

	movzx	ebx, BYTE PTR [ecx-1]
	mov	BYTE PTR [eax], bl

; 28   :            pl += 3;

	add	eax, 3

; 29   :            sl += 4;

	add	ecx, 4
	sub	esi, 1
	jne	SHORT $LL3@ConvertPix

; 20   :    {
; 21   :        unsigned char *pl = p;
; 22   :        unsigned char *sl = s;
; 23   :        for (int x = 0; x < imagew; x++)

	mov	ebx, DWORD PTR _bmpdata$[esp+28]
$LN1@ConvertPix:

; 30   :        }
; 31   :        p += bmpstride;
; 32   :        s += imagew * 4;

	mov	ecx, DWORD PTR tv285[esp+28]
	lea	eax, DWORD PTR [edi*4]
	add	ecx, eax
	add	edx, ebp
	sub	DWORD PTR tv337[esp+28], 1
	mov	DWORD PTR tv285[esp+28], ecx
	jne	SHORT $LL6@ConvertPix
$LN4@ConvertPix:

; 33   :    }
; 34   :    fz_free(image->samples);

	mov	edx, DWORD PTR _image$[esp+24]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	call	_fz_free

; 35   :    image->samples = bmpdata;

	mov	ecx, DWORD PTR _image$[esp+28]
	add	esp, 4
	mov	DWORD PTR [ecx+20], ebx
$LN8@ConvertPix:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 36   : }

	add	esp, 12					; 0000000cH
	ret	0
?ConvertPixmapForWindows@@YAXPAUfz_pixmap_s@@@Z ENDP	; ConvertPixmapForWindows
PUBLIC	?LoadFile@mupdfEngine@@QAEHPAD00@Z		; mupdfEngine::LoadFile
; Function compile flags: /Ogtpy
;	COMDAT ?LoadFile@mupdfEngine@@QAEHPAD00@Z
_TEXT	SEGMENT
_own_pwd$ = 8						; size = 4
_usr_pwd$ = 12						; size = 4
?LoadFile@mupdfEngine@@QAEHPAD00@Z PROC			; mupdfEngine::LoadFile, COMDAT
; _this$ = esi
; _fileName$ = edi

; 70   : 
; 71   : 	//start xref
; 72   : 	if(_xref==NULL){

	cmp	DWORD PTR [esi], 0
	jne	SHORT $LN8@LoadFile

; 73   : 		//_xref=new pdf_xref();
; 74   : 		_xref=pdf_newxref();

	call	_pdf_newxref
	mov	DWORD PTR [esi], eax

; 75   : 		if (!_xref){

	test	eax, eax
	jne	SHORT $LN8@LoadFile

; 76   : 			error(0,"XRef Read error, invalid file");

	push	OFFSET ??_C@_0BO@PDJELKHG@XRef?5Read?5error?0?5invalid?5file?$AA@
	push	eax
	call	?error@@YAXHPADZZ			; error
	add	esp, 8

; 77   : 			return 1;

	mov	eax, 1

; 104  : }

	ret	8
$LN8@LoadFile:

; 78   : 		}
; 79   : 	}
; 80   : 
; 81   : 	if (pdf_loadxref(_xref, (TCHAR *)fileName)) {

	mov	eax, DWORD PTR [esi]
	push	edi
	push	eax
	call	_pdf_loadxref
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@LoadFile

; 82   : 		if (pdf_repairxref(_xref, (TCHAR *)fileName)){

	mov	ecx, DWORD PTR [esi]
	push	edi
	push	ecx
	call	_pdf_repairxref
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@LoadFile

; 83   : 			error(0,"XRef Read error, corrupt data. Can not repair");

	push	OFFSET ??_C@_0CO@NNAHHPIL@XRef?5Read?5error?0?5corrupt?5data?4?5C@
	push	0
	call	?error@@YAXHPADZZ			; error
	add	esp, 8

; 84   : 			return 2;

	mov	eax, 2

; 104  : }

	ret	8
$LN6@LoadFile:

; 85   : 		}
; 86   : 	}
; 87   : 
; 88   : 	if (pdf_decryptxref(_xref)){

	mov	edx, DWORD PTR [esi]
	push	edx
	call	_pdf_decryptxref
	add	esp, 4
	test	eax, eax
	je	SHORT $LN5@LoadFile

; 89   : 		error(0,"XRef Decrypt error");

	push	OFFSET ??_C@_0BD@GNDEIHJH@XRef?5Decrypt?5error?$AA@
	push	0
	call	?error@@YAXHPADZZ			; error
	add	esp, 8

; 90   : 		return 3;

	mov	eax, 3

; 104  : }

	ret	8
$LN5@LoadFile:

; 91   : 	}
; 92   : 
; 93   : 	if (pdf_needspassword(_xref)) {

	mov	eax, DWORD PTR [esi]
	push	eax
	call	_pdf_needspassword
	add	esp, 4
	test	eax, eax
	je	SHORT $LN4@LoadFile

; 94   :         
; 95   : 		if (pdf_authenticatepassword(_xref, ""))

	mov	ecx, DWORD PTR [esi]
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	ecx
	call	_pdf_authenticatepassword
	add	esp, 8
	test	eax, eax

; 96   : 			return 0;

	jne	SHORT $LN4@LoadFile

; 97   :         if(pdf_authenticatepassword(_xref, own_pwd) || pdf_authenticatepassword(_xref, usr_pwd))

	mov	edx, DWORD PTR _own_pwd$[esp-4]
	mov	eax, DWORD PTR [esi]
	push	edx
	push	eax
	call	_pdf_authenticatepassword
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN4@LoadFile
	mov	ecx, DWORD PTR _usr_pwd$[esp-4]
	mov	edx, DWORD PTR [esi]
	push	ecx
	push	edx
	call	_pdf_authenticatepassword
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN4@LoadFile

; 98   : 				return 0;
; 99   :         error(0,"File needs password, invalid password");

	push	OFFSET ??_C@_0CG@GKJDKIFA@File?5needs?5password?0?5invalid?5pas@
	push	eax
	call	?error@@YAXHPADZZ			; error
	add	esp, 8

; 100  :         return 4;

	mov	eax, 4

; 104  : }

	ret	8
$LN4@LoadFile:

; 101  :     }
; 102  : 
; 103  : 	return 0;

	xor	eax, eax

; 104  : }

	ret	8
?LoadFile@mupdfEngine@@QAEHPAD00@Z ENDP			; mupdfEngine::LoadFile
PUBLIC	??1mupdfEngine@@QAE@XZ				; mupdfEngine::~mupdfEngine
; Function compile flags: /Ogtpy
;	COMDAT ??1mupdfEngine@@QAE@XZ
_TEXT	SEGMENT
??1mupdfEngine@@QAE@XZ PROC				; mupdfEngine::~mupdfEngine, COMDAT
; _this$ = eax

; 47   : {

	push	esi
	mov	esi, eax

; 48   : #ifdef CACHE_MUPDF_PAGES
; 49   : 	  if (_pages) {
; 50   :         for (int i=0; i < _pageCount; i++) {
; 51   :             if (_pages[i])
; 52   :                 pdf_droppage(_pages[i]);
; 53   :         }
; 54   :         free(_pages);
; 55   :     }
; 56   : #endif
; 57   : 
; 58   :     if (_xref) {

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN3@mupdfEngin

; 59   :         if (_xref->store)

	mov	eax, DWORD PTR [eax+40]
	test	eax, eax
	je	SHORT $LN2@mupdfEngin

; 60   :             pdf_dropstore(_xref->store);

	push	eax
	call	_pdf_dropstore
	add	esp, 4
$LN2@mupdfEngin:

; 61   :         _xref->store = 0;

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [eax+40], 0

; 62   :         pdf_closexref(_xref);

	mov	ecx, DWORD PTR [esi]
	push	ecx
	call	_pdf_closexref
	add	esp, 4
$LN3@mupdfEngin:

; 63   :     }
; 64   : 
; 65   :     if (_rast)

	mov	esi, DWORD PTR [esi+12]
	test	esi, esi
	je	SHORT $LN1@mupdfEngin

; 66   :         fz_droprenderer(_rast);

	push	esi
	call	_fz_droprenderer
	add	esp, 4
$LN1@mupdfEngin:
	pop	esi

; 67   : }

	ret	0
??1mupdfEngine@@QAE@XZ ENDP				; mupdfEngine::~mupdfEngine
PUBLIC	?GetPage@mupdfEngine@@QAEPAUpdf_page_s@@H@Z	; mupdfEngine::GetPage
; Function compile flags: /Ogtpy
;	COMDAT ?GetPage@mupdfEngine@@QAEPAUpdf_page_s@@H@Z
_TEXT	SEGMENT
_page$ = -4						; size = 4
?GetPage@mupdfEngine@@QAEPAUpdf_page_s@@H@Z PROC	; mupdfEngine::GetPage, COMDAT
; _this$ = esi
; _pageNo$ = eax

; 144  : {

	push	ecx

; 145  : 	pdf_page* page=NULL;
; 146  : 	fz_obj * obj;
; 147  : 
; 148  : #ifdef CACHE_MUPDF_PAGES
; 149  : 	if (!_pages){
; 150  : 		int _pageCount;
; 151  : 		pdf_getpagecount(_xref,&_pageCount);
; 152  :         _pages = (pdf_page**)malloc(sizeof(pdf_page*) * _pageCount);
; 153  : 		for (int i = 0; i < _pageCount; i++)
; 154  : 			_pages[i] = NULL;
; 155  : 	}
; 156  :     page = _pages[pageNo-1];
; 157  :     if (page) 
; 158  :         return page;
; 159  : #endif   
; 160  :     obj = pdf_getpageobject(_xref, pageNo);

	mov	ecx, DWORD PTR [esi]
	push	eax
	push	ecx
	mov	DWORD PTR _page$[esp+12], 0
	call	_pdf_getpageobject
	add	esp, 8

; 161  : 	if(obj){

	test	eax, eax
	je	SHORT $LN1@GetPage

; 162  :         if(pdf_loadpage(&page, _xref,obj))

	mov	edx, DWORD PTR [esi]
	push	eax
	push	edx
	lea	eax, DWORD PTR _page$[esp+12]
	push	eax
	call	_pdf_loadpage
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN1@GetPage

; 163  : 			return NULL;

	xor	eax, eax

; 169  : }

	pop	ecx
	ret	0
$LN1@GetPage:

; 164  : 	}
; 165  : #ifdef CACHE_MUPDF_PAGES
; 166  : 	_pages[pageNo-1]=page;
; 167  : #endif
; 168  :     return page;

	mov	eax, DWORD PTR _page$[esp+4]

; 169  : }

	pop	ecx
	ret	0
?GetPage@mupdfEngine@@QAEPAUpdf_page_s@@H@Z ENDP	; mupdfEngine::GetPage
_TEXT	ENDS
PUBLIC	?display@mupdfEngine@@QAEPAUfz_pixmap_s@@PAVAuxOutputDev@@HHNP6AHPAX@Z1@Z ; mupdfEngine::display
; Function compile flags: /Ogtpy
;	COMDAT ?display@mupdfEngine@@QAEPAUfz_pixmap_s@@PAVAuxOutputDev@@HHNP6AHPAX@Z1@Z
_TEXT	SEGMENT
_image$ = -64						; size = 4
_page$192458 = -60					; size = 4
tv241 = -56						; size = 4
tv196 = -52						; size = 4
$T192455 = -48						; size = 16
$T192453 = -48						; size = 16
$T192451 = -48						; size = 24
_ctm$ = -24						; size = 24
_out$ = 8						; size = 4
_rotate$ = 12						; size = 4
_zoom$ = 16						; size = 8
?display@mupdfEngine@@QAEPAUfz_pixmap_s@@PAVAuxOutputDev@@HHNP6AHPAX@Z1@Z PROC ; mupdfEngine::display, COMDAT
; _this$ = ecx
; _pageNo$ = eax

; 107  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	esi, ecx

; 108  :     fz_matrix ctm;
; 109  :     fz_rect bbox;
; 110  :     fz_pixmap* image = NULL;
; 111  : 	pdf_page* page = GetPage(pageNo);

	mov	ecx, DWORD PTR [esi]
	push	eax
	xor	ebx, ebx
	push	ecx
	mov	DWORD PTR _image$[esp+88], ebx
	mov	DWORD PTR _page$192458[esp+88], ebx
	call	_pdf_getpageobject
	add	esp, 8
	cmp	eax, ebx
	je	SHORT $LN6@display
	mov	edx, DWORD PTR [esi]
	push	eax
	push	edx
	lea	eax, DWORD PTR _page$192458[esp+88]
	push	eax
	call	_pdf_loadpage
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN6@display
	xor	edi, edi
	jmp	SHORT $LN8@display
$LN6@display:
	mov	edi, DWORD PTR _page$192458[esp+80]
$LN8@display:

; 112  : 	fz_rect *pageRect = &page->mediabox;
; 113  : 
; 114  :     if (!_rast) 

	lea	eax, DWORD PTR [esi+12]
	mov	DWORD PTR tv196[esp+80], eax
	cmp	DWORD PTR [eax], ebx
	jne	SHORT $LN3@display

; 115  :         fz_newrenderer(&_rast, pdf_devicergb, 0, 1024 * 512);

	mov	ecx, DWORD PTR _pdf_devicergb
	push	524288					; 00080000H
	push	ebx
	push	ecx
	push	eax
	call	_fz_newrenderer
	add	esp, 16					; 00000010H
$LN3@display:

; 116  : 	if (!page){

	cmp	edi, ebx
	jne	SHORT $LN2@display

; 117  :         error(0,"Can not create mupdf renderer");

	push	OFFSET ??_C@_0BO@KNACDEIG@Can?5not?5create?5mupdf?5renderer?$AA@
	push	ebx
	call	?error@@YAXHPADZZ			; error
	add	esp, 8

; 118  : 		return NULL;

	xor	eax, eax

; 141  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN2@display:

; 119  : 	}
; 120  : 
; 121  :     ctm = viewctm(page, zoom, rotate);

	mov	edx, DWORD PTR _rotate$[ebp]
	fld	QWORD PTR _zoom$[ebp]
	fstp	DWORD PTR tv241[esp+80]
	push	edx
	fld	DWORD PTR tv241[esp+84]
	push	ecx
	lea	esi, DWORD PTR $T192451[esp+88]
	fstp	DWORD PTR [esp]
	call	?viewctm@mupdfEngine@@QAE?AUfz_matrix_s@@PAUpdf_page_s@@MH@Z ; mupdfEngine::viewctm
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [eax+12]
	mov	esi, DWORD PTR [eax]
	mov	ebx, DWORD PTR [eax+4]
	mov	DWORD PTR _ctm$[esp+92], edx
	mov	edx, DWORD PTR [eax+20]
	mov	DWORD PTR _ctm$[esp+100], edx

; 122  :     bbox = fz_transformaabb(ctm, *pageRect);

	mov	edx, DWORD PTR [edi]
	mov	DWORD PTR _ctm$[esp+88], ecx
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _ctm$[esp+96], ecx
	sub	esp, 16					; 00000010H
	mov	ecx, esp
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [edi+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [edi+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [edi+12]
	mov	DWORD PTR [ecx+12], edx
	sub	esp, 24					; 00000018H
	mov	ecx, esp
	mov	edx, esi
	mov	DWORD PTR [ecx], edx
	mov	edx, ebx
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	edx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR [ecx+16], edx
	mov	DWORD PTR [ecx+20], eax
	lea	ecx, DWORD PTR $T192453[esp+120]
	push	ecx
	call	_fz_transformaabb

; 123  : 	//ctm = fz_invertmatrix(ctm);
; 124  : 	if(fz_rendertree(&image, _rast, page->tree, ctm, fz_roundrect(bbox), 1)){

	mov	edx, DWORD PTR [eax]
	add	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+8], edx
	mov	DWORD PTR [ecx+12], eax
	lea	ecx, DWORD PTR $T192455[esp+96]
	push	ecx
	call	_fz_roundrect
	mov	edx, DWORD PTR [eax]
	add	esp, 20					; 00000014H
	push	1
	sub	esp, 16					; 00000010H
	mov	ecx, esp
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR _ctm$[esp+112]
	mov	DWORD PTR [ecx+12], eax
	mov	ecx, DWORD PTR _ctm$[esp+108]
	sub	esp, 24					; 00000018H
	mov	eax, esp
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR _ctm$[esp+140]
	mov	DWORD PTR [eax+12], edx
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR _ctm$[esp+144]
	mov	ecx, DWORD PTR tv196[esp+124]
	mov	DWORD PTR [eax+20], edx
	mov	eax, DWORD PTR [edi+24]
	mov	edx, DWORD PTR [ecx]
	push	eax
	push	edx
	lea	eax, DWORD PTR _image$[esp+132]
	push	eax
	call	_fz_rendertree
	add	esp, 56					; 00000038H
	test	eax, eax
	je	SHORT $LN1@display

; 125  : 		error(0,"Can not render page, unknown problem with mupdf");

	push	OFFSET ??_C@_0DA@NOMLDOFL@Can?5not?5render?5page?0?5unknown?5pro@
	push	0
	call	?error@@YAXHPADZZ			; error
	add	esp, 8

; 126  : 		return NULL;

	xor	eax, eax

; 141  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN1@display:

; 127  : 	}
; 128  : 	out->setSize(image->w,image->h);

	mov	eax, DWORD PTR _image$[esp+80]
	fild	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _out$[ebp]
	fild	DWORD PTR [eax+8]

; 129  : 	out->SetDataPtr(image->samples);
; 130  : 
; 131  : 	/*double dctm[6] = {ctm.a,ctm.b,ctm.c,ctm.d,ctm.e,ctm.f};
; 132  : 	out->setDefCTM(dctm);
; 133  : 	out->setDefICTM(dctm);*/
; 134  : 
; 135  :     ConvertPixmapForWindows(image);

	push	eax
	fstp	QWORD PTR [ecx+24]
	fstp	QWORD PTR [ecx+32]
	mov	edx, DWORD PTR [eax+20]
	mov	DWORD PTR [ecx+8], edx
	call	?ConvertPixmapForWindows@@YAXPAUfz_pixmap_s@@@Z ; ConvertPixmapForWindows
	add	esp, 4

; 136  : 
; 137  : #ifndef CACHE_MUPDF_PAGES
; 138  : 	pdf_droppage(page);

	push	edi
	call	_pdf_droppage

; 139  : #endif
; 140  : 	return image;

	mov	eax, DWORD PTR _image$[esp+84]
	add	esp, 4

; 141  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?display@mupdfEngine@@QAEPAUfz_pixmap_s@@PAVAuxOutputDev@@HHNP6AHPAX@Z1@Z ENDP ; mupdfEngine::display
END
